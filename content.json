[{"title":"Java设计模式之单例模式","date":"2019-02-24T12:38:30.000Z","path":"2019/02/24/Java设计模式之单例模式/","text":"前言 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。 单例模式的几种实现方式 饿汉模式 懒汉模式 双重锁定 静态内部类 枚举单例 饿汉模式 在类加载时就完成了初始化，当单例很大的话，将会浪费很多的内存，所以类加载较慢，但获取对象的速度快。 1234567891011public class Singleton &#123; private static Singleton instance = new Singleton();//静态私有成员 private Singleton() &#123;//私有构造函数 &#125; public static Singleton getInstance() &#123; //静态，不用同步（类加载时已初始化，不会有多线程的问题） return instance; &#125;&#125; 懒汉模式 在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢。 1234567891011121314public class Singleton &#123; private static Singleton instance = null;//静态私有成员,没有初始化 private Singleton() &#123;//私有构造函数 &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 测试用例： 123456public static void main(String[] args) &#123; // write your code here Singleton s1 = new Singleton(); Singleton s2 = new Singleton(); System.out.println(s1 == s2); &#125; 输出结果如下所示： 单例模式因为Singleton类封装它的唯一实例，这样它可以严格的控制客户端怎样访问它以及何时访问它，也就是对唯一实例的受控访问。 多线程中的单例模式 在单线程下这种写法是可以的，但是在多线程下存在线程安全问题。当同一时间有两个或者两个以上线程进入getInstance()方法时，因为刚开始single都是null，几个线程都同时满足if(single==null)这个条件，就会同时new Singleton()这个对象。 测试用例： 1234567891011121314151617181920212223//SingletonThread类public class SingletonThread implements Runnable &#123; private Set&lt;Singleton&gt; set = new HashSet&lt;Singleton&gt;(); @Override public void run() &#123; Singleton single = Singleton.getInstance(); set.add(single); System.out.println(\"Set的大小为：\" + set.size() + \",\" + set); &#125;&#125;//main函数public static void main(String[] args) &#123; // write your code here SingletonThread t=new SingletonThread(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125; 输出结果如下所示： 那么应该如何优化呢？在高并发情况下，做到线程安全，保证多线程环境下同时访问也不会造成多个实例的出现，我们可以通过加上synchronized修饰符解决。 123456public synchronized static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 输出结果如下所示： 上述方式通过为 getInstence() 方法增加 synchronized 关键字，迫使每个线程在进入这个方法前，要先等候别的线程离开该方法，即不会有两个线程可以同时进入此方法执行 new Singleton()，从而保证了单例的有效。但它的致命缺陷是效率太低了，每个线程每次执行 getInstance() 方法获取类的实例时，都会进行同步。而事实上实例创建完成后，同步就变为不必要的开销了，这样做在高并发下必然会拖垮性能。我们继续优化。 双重锁定1234567891011121314151617181920private volatile static Singleton instance = null; private Singleton() &#123;//私有构造函数 System.out.println(\"生成一个Singleton实例\"); &#125; public synchronized static Singleton getInstance() &#123; // 第一重检查锁定 if (instance == null) &#123; // 同步锁定代码块 synchronized (Singleton.class) &#123; // 第二重检查锁定 if (instance == null) &#123; // 实例化对象 instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 当instance不为null的时候，直接返回实例；当instance为null时并且有多个线程调用getInstance方法时，通过第一重判断，然后通过synchronized机制，只有一个线程进入，另外的处于等待，如果不加第二重判断，第一个线程创建了实例，而后面的线程又可以创建新的实例，这样就没有达到单例的效果。从代码中可以看到在修饰instance变量的时候用到了volatile修饰符，那么起到了什么作用呢？ 禁止指令重排序。我们知道new Singleton()是一个非原子操作，编译器可能会重排序【构造函数可能在整个对象初始化完成前执行完毕，即赋值操作（只是在内存中开辟一片存储区域后直接返回内存的引用）在初始化对象前完成】。 保证可见性。线程1在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程2在主存中判断instance还是null，那么线程2又将在自己的工作线程中创建一个实例，这样就创建了多个实例。 静态内部类 静态内部类比双重检查锁定和在getInstance()方法上加同步都要好，实现了线程安全又避免了同步带来的性能影响。 1234567891011121314public class Singleton &#123; private Singleton() &#123;//私有构造函数 System.out.println(\"生成一个Singleton实例\"); &#125; public static final Singleton getInstance() &#123; return SingletonInner.INSTANCE; &#125; private static class SingletonInner &#123; private static final Singleton INSTANCE = new Singleton(); &#125;&#125; 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。即当SingleTon第一次被加载时，并不需要去加载SingletonInner，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE,第一次调用getInstance()方法会导致虚拟机加载SingletonInner类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。 枚举单例12345678910111213141516171819202122232425public class Instance &#123; public static Instance getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; public enum Singleton &#123; INSTANCE; private Instance instance; /** * JVM保证这个方法绝对只调用一次 */ Singleton() &#123; instance = new Instance(); &#125; public Instance getInstance() &#123; return instance; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://lzxhh2017.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lzxhh2017.github.io/tags/设计模式/"}]},{"title":"Java设计模式之策略模式","date":"2019-02-21T09:17:21.000Z","path":"2019/02/21/Java设计模式之策略模式/","text":"前言 设计模式作为一种经典的开发实践常常需要我们去深入的理解，而策略模式作为设计模式的一种，使用频率也是相对来说比较高的，Java中TreeSet集合就采用了经典的策略模式的思想。 简单工厂实现 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同的属性和功能的对象的抽象集合才是类。打一折和九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，应该是一个类。代码结构图如下： 现金收费抽象类： 1234public interface CashSuper&#123; public double acceptCash(double money); &#125; 正常收费子类： 1234567public class CashNormal implements CashSuper &#123; public double acceptCash(double money) &#123; return money; &#125; &#125; 打折收费子类： 1234567891011121314public class CashRebate implements CashSuper &#123; private double moneyRebate = 1; public CashRebate(double moneyRebate) &#123; this.moneyRebate = moneyRebate; &#125; public double acceptCash(double money) &#123; return money * moneyRebate; &#125; &#125; 返利收费子类： 123456789101112131415161718192021public class CashReturn implements CashSuper &#123; private double moneyCondition = 0; private double moneyReturn = 0; public CashReturn(double moneyCondition, double moneyReturn) &#123; this.moneyCondition = moneyCondition; this.moneyReturn = moneyReturn; &#125; public double acceptCash(double money) &#123; double result = money; if (money &gt;= moneyCondition) &#123; result = money - money / moneyCondition * moneyReturn; &#125; return result; &#125; &#125; 现金收费工厂类： 123456789101112131415161718192021public class CashFactory &#123; public static CashSuper createCash(String type) &#123; CashSuper cs = null; if (\"正常收费\".equals(type)) &#123; cs = new CashNormal(); &#125; else if (\"满300返100\".equals(type)) &#123; cs = new CashReturn(300, 100); &#125; else if (\"打8折\".equals(type)) &#123; cs = new CashRebate(0.8); &#125; return cs; &#125; &#125; 客户端程序： 12345678910111213141516171819202122public class Main &#123; private static double total = 0; public static void main(String[] args) &#123; consume(\"正常收费\", 1, 1000); consume(\"满300返100\", 1, 1000); consume(\"打8折\", 1, 1000); System.out.println(\"总计:\" + total); &#125; public static void consume(String type, int num, double price) &#123; CashSuper csuper = CashFactory.createCash(type); double totalPrices = 0; totalPrices = csuper.acceptCash(num * price); total += totalPrices; System.out.println(\"单价:\" + price + \" 数量:\" + num + \"合计:\" + totalPrices); &#125; &#125; 由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度的，每次维护或扩展收费方式都要改动这个工厂，以致代码需要重新编译部署，这是非常糟糕的处理方式，所以用它不是最好的办法。 策略模式 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。结构图如下所示： Strategy类，定义所有支持的算法的公共接口 1234public interface Strategy &#123; public void algorithmInterface(); &#125; ConcreteStrategy封装了具体的算法或行为，继承于Strategy 123456789101112131415161718192021public class ConcreteStrategyA implements Strategy &#123; public void algorithmInterface() &#123; System.out.println(\"算法A实现\"); &#125; &#125; public class ConcreteStrategyB implements Strategy &#123; public void algorithmInterface() &#123; System.out.println(\"算法A实现\"); &#125; &#125; public class ConcreteStrategyC implements Strategy &#123; public void algorithmInterface() &#123; System.out.println(\"算法C实现\"); &#125; &#125; Context用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用 1234567891011121314public class Context &#123; private Strategy strategy; public Context(Strategy strategy) //初始化时，传入具体的策略对象 &#123; this.strategy = strategy; &#125; public void contextInterface()//根据具体的策略对象，调用其算法的方法 &#123; strategy.algorithmInterface(); &#125; &#125; 客户端代码 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); &#125; &#125; 策略模式实现 正常收费CashNormal、打折收费CashRebate和返利收费CashReturn就是三个具体策略，也就是策略模式中说的具体算法。代码结构图如下： CashContext类 1234567891011121314public class CashContext &#123; CashSuper cashSuper; public CashContext(CashSuper cashSuper) &#123; this.cashSuper = cashSuper; &#125; public double acceptCash(double money) &#123; return cashSuper.acceptCash(money); &#125; &#125; 客户端代码 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; private static double total = 0; public static void main(String[] args) &#123; consume(\"正常收费\", 1, 1000); consume(\"满300返100\", 1, 1000); consume(\"打8折\", 1, 1000); System.out.println(\"总计:\" + total); &#125; public static void consume(String type, int num, double price) &#123; CashContext cashContext = null; if (\"正常收费\".equals(type)) &#123; cashContext = new CashContext(new CashNormal()); &#125; else if (\"满300返100\".equals(type)) &#123; cashContext = new CashContext(new CashReturn(300, 100)); &#125; else if (\"打8折\".equals(type)) &#123; cashContext = new CashContext(new CashRebate(0.8)); &#125; double totalPrices = cashContext.acceptCash(num * price); total += totalPrices; System.out.println(\"单价:\" + price + \" 数量:\" + num + \"合计:\" + totalPrices); &#125; &#125; 但是代码还是老样子，需要在客户端判断用哪一个算法。如何优化呢？ 策略与简单工厂结合 改造后的CashContext 123456789101112131415161718192021222324252627282930public class CashContext &#123; CashSuper cashSuper; public CashContext(CashSuper cashSuper) &#123; this.cashSuper = cashSuper; &#125; public CashContext(String type) &#123; if (\"正常收费\".equals(type)) &#123; cashSuper = new CashNormal(); &#125; else if (\"满300返100\".equals(type)) &#123; cashSuper = new CashReturn(300, 100); &#125; else if (\"打8折\".equals(type)) &#123; cashSuper = new CashRebate(0.8); &#125; &#125; public double acceptCash(double money) &#123; return cashSuper.acceptCash(money); &#125; &#125; 客户端代码 1234567891011121314151617181920212223public class Main &#123; private static double total = 0; public static void main(String[] args) &#123; consume(\"正常收费\", 1, 1000); consume(\"满300返100\", 1, 1000); consume(\"打8折\", 1, 1000); System.out.println(\"总计:\" + total); &#125; public static void consume(String type, int num, double price) &#123; CashContext cashContext = new CashContext(type); double totalPrices = cashContext.acceptCash(num * price); total += totalPrices; System.out.println(\"单价:\" + price + \" 数量:\" + num + \"合计:\" + totalPrices); &#125; &#125; 简单工厂模式需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂模式结合的用法，客户端就只需要认识一个类CashContext，耦合度更加降低。 策略模式解析 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法与使用算法之间的耦合。 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 当不同的行为堆砌于一个类中，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。 策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。","categories":[{"name":"Java","slug":"Java","permalink":"https://lzxhh2017.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lzxhh2017.github.io/tags/设计模式/"}]},{"title":"Java设计模式之工厂模式","date":"2019-02-20T03:02:06.000Z","path":"2019/02/20/Java设计模式之工厂模式/","text":"前言 工厂模式实现了创建者和调用者的分离，实现了更好的解耦。 详细分类：（1）简单工厂模式（2）工厂方式模式（3）抽象工厂模式 下面将逐一介绍：简单工厂模式以计算器为例，结构图如下所示： 简单工厂类是这样写的： 123456789101112131415161718192021class OperationFactory&#123; public static Operation createOperate(String operate)&#123; Operation Oper = null; switch (operate) &#123; case \"+\": oper = new OperationAdd(); break; case \"-\": oper = new OperationSub(); break; case \"*\": oper = new OperationMul(); break; case \"/\": oper = new OperationDiv(); break; &#125; return oper; &#125;&#125; 客户端的应用 12345Operation oper;oper = OperationFactory.createOperate(\"+\");oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult(); 如果现在需要增加其他运算，比如求M的N次方，或者求M的N次方根，这样复杂性就增加了。因为如果加一个“求M的N次方”的功能，我们一定要给运算工厂类的方法添加“Case”的分支条件，这样即违背了开放-封闭原则（OCP(开闭原则, Open-Closed Principle)：一个软件的实体应当对扩展开放，对修改关闭）。 工厂方法模式实现结构图如下： 先构建一个工厂接口： 1234interface IFactory&#123; Operation CreateOperation();&#125; 然后加减乘除分别建立一个工厂去实现这个接口： 12345678910111213141516171819202122232425262728293031class AddFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationAdd(); &#125;&#125;class SubFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationSub(); &#125;&#125;class MulFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationMul(); &#125;&#125;class DivFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationDiv(); &#125;&#125; 客户端的实现： 12345IFactory operFactory ＝ new AddFactory();Operation oper = operFactory.CreateOperation();oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult(); 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式结构图： 根据依赖倒转原则（ DIP(依赖倒转原则,Dependence Inversion Principle)：要针对接口编程，不要针对实现编程），我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂，当我们需要增加新的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。 这样整个工厂和产品体系其实都没有修改的变化，而只是扩展的变化，这就完全符合了开放－封闭原则的精神。 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移动到了客户端代码来运行。你想要加功能，本来是该工厂类的，而现在是修改客户端。 抽象工厂模式为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。 抽象工厂模式与工厂方法模式的区别 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。 在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。 明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。 1234567891011121314151617181920212223242526272829303132333435363738interface IProduct1 &#123; public void show(); &#125; interface IProduct2 &#123; public void show(); &#125; class Product1 implements IProduct1 &#123; public void show() &#123; System.out.println(\"这是1型产品\"); &#125; &#125; class Product2 implements IProduct2 &#123; public void show() &#123; System.out.println(\"这是2型产品\"); &#125; &#125; interface IFactory &#123; public IProduct1 createProduct1(); public IProduct2 createProduct2(); &#125; class Factory implements IFactory&#123; public IProduct1 createProduct1() &#123; return new Product1(); &#125; public IProduct2 createProduct2() &#123; return new Product2(); &#125; &#125; public class Client &#123; public static void main(String[] args)&#123; IFactory factory = new Factory(); factory.createProduct1().show(); factory.createProduct2().show(); &#125; &#125; 抽象工厂模式的优点：抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。 抽象工厂模式的缺点：产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。 适用场景：当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。","categories":[{"name":"Java","slug":"Java","permalink":"https://lzxhh2017.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lzxhh2017.github.io/tags/设计模式/"}]},{"title":"Java关键字static","date":"2019-02-19T14:38:09.000Z","path":"2019/02/19/Java关键字static/","text":"前言 static是java中一重要的关键字，在一定环境下使用，可以提高程序的运行性能，优化程序的结构。（静态方法不能调用非静态的成员变量和成员方法。非静态方法可以调用静态的成员变量和成员方法。）因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。 其主要应用有以下几方面： 1.static修饰的成员变量，称为类变量/静态变量，以实现所有对象对该成员的共享。 2.static修饰的成员方法，称为类方法/静态方法，可直接通过类名调用，无需创建对象。 3.形成静态代码块，优化程序性能。 4.静态导包，一般将类的方法直接导入到当前类中，从而直接使用方法名即可调用类方法，更加方便。 5.修饰内部类，无需实例化外部类就可以调用内部类。 具体代码如下所示： 123456789101112131415161718192021222324252627public class Student &#123; String name; static int age; @Override public String toString() &#123; // TODO Auto-generated method stub return \"Name:\" + name + \", Age:\" + age; &#125; @SuppressWarnings(\"static-access\") public static void main(String[] args) &#123; Student s1 = new Student(); s1.name = \"张三\"; s1.age = 20; Student s2 = new Student(); s2.name = \"李四\"; s2.age = 10; System.out.println(s1); System.out.println(s2); &#125;&#125;/**输出结果：Name:张三, Age:10Name:李四, Age:10*/ 如上述代码所示，s1和s2两个对象分别存储在内存中堆区域的不同地址中，所以他们之间相互不会干扰。然而static关键字修饰了成员变量age，让其变成类的所属，而不是对象的所属，任何该类实例的对象都可以共享使用它。所以，输出的age均是最终赋给的10。如果去掉static，对象之间互不影响，输出如下： 123456789101112131415161718192021222324//Testpublic class Test extends Base &#123; static &#123; System.out.println(\"static静态块1\"); &#125; public Test() &#123; System.out.println(\"test构造器\"); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125;//Basepublic class Base &#123; static &#123; System.out.println(\"static静态块2\"); &#125; public Base() &#123; System.out.println(\"base构造器\"); &#125;&#125; 如上述代码，static代码块随类的加载一起加载。static修饰的变量方法比其他变量方法优先加载，且只加载一次。加载子类时，会首先加载父类。由此可以分析：在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。 12345678910111213141516171819//A.javapackage demo;public class A &#123; public static void outWord(Object o) &#123; System.out.println(o); &#125;&#125;//B.javapackage demo;import static demo.A.*;public class B &#123; public static void main(String[] args) &#123; outWord(\"Hello World!\");//A.outWord(\"Hello World!\");不用static的情況 &#125;&#125; 如上述代码，A.java中包含一个简单的静态方法，在B.java中我们用static关键字将A类导入，由此，便无需使用“类名.方法名”的方法去调用类方法了，直接可以采用”方法名”去调用类方法。 123456789101112131415161718192021222324252627282930313233public class C &#123; static &#123; System.out.println(\"C静态块\"); &#125; public C() &#123; System.out.println(\"C构造器\"); &#125; static class D &#123; static &#123; System.out.println(\"D静态块\"); &#125; public D() &#123; System.out.println(\"D构造器\"); &#125; &#125;&#125;//测试类import demo.C;public class Test&#123; public static void main(String[] args) &#123; new C.D(); &#125;&#125;/**输出结果：D静态块D构造器*/ 如上述代码，用static修饰内部类，外部类可以直接调用内部类，因为static修饰的的内部类是在加载外部类的同时加载的，所以，并不要实例化外部类就能直接调用静态内部类。例子中，在进入Test的main方法之前，加载Test类，然后执行new C.D()这里需要注意：因为D是静态的，所以这里并不需要加载外部类和实例化外部类，可以直接加载D并实例化。 此外，static另一个很重要的应用就是实现单例设计模式。单利模式的特点是该类只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象，于是只能把创建对象的方法声明为static，程序实例如下： 12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://lzxhh2017.github.io/categories/Java/"}],"tags":[{"name":"static","slug":"static","permalink":"https://lzxhh2017.github.io/tags/static/"}]},{"title":"List去重之Set","date":"2019-02-17T14:17:49.000Z","path":"2019/02/17/List去重之Set/","text":"前言 我们都知道，List集合是允许重复的元素存在的。这里要阐明的List去重是通过将List集合转换成Set。Set是最简单的一种集合，不保存重复的元素，集合中的对象不按特定的方式排序，并且没有重复对象。 我们新建一个Test类，如下所示： 1234567891011121314151617181920public class Test &#123; @SuppressWarnings(&#123; \"unchecked\", \"rawtypes\" &#125;) public static void main(String[] args) &#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(1); System.out.println(list); //创建一个set集合 Set set = new HashSet(); //创建一个新的list集合 List newList = new ArrayList(); set.addAll(list); newList.addAll(set); System.out.println(newList); &#125;&#125; 输出结果为： 从上图可以看出，通过将List集合转化成Set集合，达到了去重的效果。 但是当list集合中存储的不是元素，而是对象类型的时候，我们还可以简单的把list集合转换成set集合吗？那么我们来验证一下。 我们先定义一个对象（User）类： 12345678910111213141516171819202122232425262728293031323334public class User &#123; private String name; private String sex; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public User(String name, String sex, Integer age) &#123; super(); this.name = name; this.sex = sex; this.age = age; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return \"&#123;name=\" + name + \",\" + \"sex=\" + sex + \",\" + \"age=\" + age + \"&#125;\"; &#125;&#125; 我们使用上面的set去重的方法去重： 1234567891011121314public class Test1 &#123; public static void main(String[] args) &#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"张三\", \"男\", 23)); list.add(new User(\"李四\", \"女\", 23)); list.add(new User(\"王五\", \"男\", 23)); list.add(new User(\"张三\", \"男\", 23)); System.out.println(list.toString()); Set&lt;User&gt; setList = new HashSet&lt;User&gt;(); setList.addAll(list); System.out.println(setList.toString()); &#125;&#125; 运行后输出的结果为： 从上图我们可以看出，出现两个张三，并没有达到去重的效果。 那么应该如何去重呢？我们都知道HashSet可以用来去重，那么是如何去重的呢？我们看源码可以看出HashSet的去重就是根据HashMap实现的，而HashMap的实现又完全依赖于hashcode和equals方法。 由此我们可以推断出，当list集合中存储的是对象时，我们必须在对象的实体类中重写equals()方法和hashCode()方法，如下面所示： 1234567891011121314@Override public int hashCode() &#123; // TODO Auto-generated method stub String str = name + sex + age; return str.hashCode(); &#125; @Override public boolean equals(Object obj) &#123; // TODO Auto-generated method stub User user = (User) obj; return name.equals(user.name) &amp;&amp; sex.equals(user.sex) &amp;&amp; age.equals(user.age); &#125; 在User类中重写这两个方法后，我们再去运行Test1这个类，我们可以发现去重成功了。如下图所示： 下面我们来看下equals()方法和hashCode()方法的具体实现： equals() 从源码中可以看出，两个对象相互比较时，首先会比较地址，如果是同一对象的引用，则判断为对象相等，结果返回true；如果地址不一样，则说明不是引用同一个对象，equals方法则会对两个字符串对象内的字符进行挨个比较，如果完全相等返回true，否则返回false。 hashCode() hashCode()是Object中的方法。由于hashCode方法定义在Object类中，所以每个对象都有一个默认的散列码，其值为对象的存储地址。 当equals方法被重新定义，hashCode方法也要跟着重新定义，以便用户可以将对象插入到散列表中。 Equals和hashCode的定义必须是一致的：如果a.equals(b)返回true，那么a.hashCode()就必须与b.hashCode()具有相同的值。","categories":[{"name":"Java","slug":"Java","permalink":"https://lzxhh2017.github.io/categories/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://lzxhh2017.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://lzxhh2017.github.io/tags/Set/"}]},{"title":"你想了解的前端知识都在这里","date":"2018-12-24T12:55:43.000Z","path":"2018/12/24/你想了解的前端知识都在这里/","text":"前言 这里介绍了HTML5、CSS3、JS、ES6、包管理工具、前端框架以及构建工具等前端网站。 核心 Core HTML5W3C http://www.w3school.com.cn/html5/W3C https://www.w3.org/html/ig/zh/wiki/HTML5菜鸟教程 http://www.runoob.com/html/html5-intro.htmlHTML5中文门户 http://www.html5cn.org/ CSS3W3C CSS教程 http://www.w3school.com.cn/css/index.aspW3C CSS3教程 http://www.w3school.com.cn/css3/index.asp菜鸟教程CSS教程 http://www.runoob.com/css/css-tutorial.html菜鸟教程CSS3教程 http://www.runoob.com/css3/css3-tutorial.htmlCSS参考手册 http://css.doyoe.com/ JSW3C http://www.w3school.com.cn/js/菜鸟教程 http://www.runoob.com/js/js-tutorial.html廖雪峰js教程 http://www.liaoxuefeng.comjs标准参考教程-阮一峰http://javascript.ruanyifeng.com/ jQueryW3C http://www.w3school.com.cn/jquery/菜鸟教程 http://www.runoob.com/jquery/jquery-tutorial.html极客学院 http://wiki.jikexueyuan.com/project/jquery-tutorial/廖雪峰 http://www.liaoxuefeng.com/wiki/参考手册 http://www.css88.com/jqapi-1.9/参考手册 http://www.runoob.com/manual/jquery/ ES6阮一峰ES6 http://es6.ruanyifeng.com/极客学院 http://wiki.jikexueyuan.com/project/es6/JavaScript 标准参考 阮一峰http://javascript.ruanyifeng.com/advanced/ecmascript6.html 插件parallel.js: 前后端通用的一个并行库zepto: 用于现代浏览器的兼容 jQuery 的库totoro: 稳定的跨浏览器测试工具TheaterJS: 一个用于模拟人输入状态的 JS 库stellar.js: 前端用于实现异步滚动效果的库，现已不再维护skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，看真相Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序regulex: 用于生成 正则表达式 的可视化流程图markdown-it: 新型 Markdown 解析器，快速，支持插件multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Docscreenfull.js: 全屏插件，支持各大浏览器lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用jquery.hotkeys: jQuery 插件，用于绑定热键breach_core: Javascript 编写的 Browser (浏览器)octocard: 用于生成 Github 信息卡片的库github-cards: 用于生成 Github 信息卡片的库money.js: 轻量级货币转换库，web 和 node 皆可用accounting.js: 轻量级的数字、货币转换库javascript-algorithms: Javascript 实现的各种算法集合lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升seajs: 前端模块加载器，解决模块化、依赖等问题jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库js.js: Javascript 实现的 javascript JITjquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大todomvc: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库localForage: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口EventEmitter: 浏览器版的 EventEmitterjquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据knockout: 前端 MVVM 框架，用于开发富前端应用mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品zoomooz: jQuery 插件，用来处理浏览器缩放fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 Reactbackbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果jquery-validation: jQuery 的一个插件，用于校验 Form 表单BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度qrcode-generator: 各种语言的二维码生成工具device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSSjquery-qrcode: jQuery 插件，用来生成二维码Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demolazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片progressbar.js: 简洁美观的进度条，扁平化pigshell: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务spectrum: Js实现的颜色选择器 (Colorpicker)jQuery.countdown: jQuery 倒计时插件summernote: WYSIWYG 富文本编辑器awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器trix: Basecamp 公司出品的富文本编辑器，简洁小巧sensor.js: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等hyhyhy: 用于创建 基于 HTML5 的 演示文稿swipebox: jQuery 插件，用于处理移动端的触摸事件FileAPI: 前端用户处理文件（拖放、多文件上传等）Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuerySwiper: 用于实现浏览器上的滑动切换效果，支持硬件加速matter-js: 2D 物理效果引擎，碰撞、弹跳等jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库c3: 基于 D3 的图表库echarts: 企业级图表库，百度开发parallax.js: 一个用于响应智能手机 orientation 的库jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器wysihtml: 富文本编辑器，适用于现代浏览器slip: 一个通过滑动或者拖拽来操控列表的库evil-icons: 一个矢量图库，提供 Ruby/Node 等支持PhotoSwipe: JS 的一个图片展示库focusable: 是页面上一个元素高亮的库，有图有真相firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefoxjquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5mobile-angular-ui: 基于angularjs和bootstarp的web app开发框架interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库rebound-js: 实现部分物理效果，Facebook 出品basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品accessible-html5-video-player: Paypal 出品的 Video 播放器loading: 几种 Loading 效果，基于 SVGflippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的move.js: 基于 CSS3 的前端动画框架scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 DemoModernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库foundation: 另一款前端模版框架，类似于 BootstrapFlat-UI: Bootstrap 的一款主题，简洁美观iCheck: 一款漂亮的 Checkbox 插件Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kbslick: 功能异常强大的一个图片滑动切换效果库SocialButtons: 漂亮的社交按钮sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库web-animations-js: Javascript 实现的 Web Animation APIvivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画plyr: 轻量, 小巧, 美观的 HTML5 视频播放器timesheet.js: 基于 HTML5 &amp; CSS3 时间表slideout: 一个非常美观的侧滑菜单 包管理工具 Package ManagersNPM菜鸟教程NPM 使用介绍 http://www.runoob.com/nodejs/nodejs-npm.html淘宝 NPM 镜像 https://npm.taobao.org/npm 模块安装机制简介 http://www.ruanyifeng.com/blog/2016/01/npm-install.htmlnpm包搜索地址 https://www.npmjs.com/ BowerBower中文网 http://www.bowercn.com/Bower：客户端库管理工具-阮一峰 http://javascript.ruanyifeng.com/tool/bower.html Yarnyarn中文网 https://yarnpkg.com/zh-Hans/快速、可靠、安全的依赖管理YARN 简介 https://www.ibm.com/developerworks/cn/data/library/bd-yarn-intro/ 编辑器 Text EditorsWebStorm官网下载 http://www.jetbrains.com/webstorm/download前端网破解版下载 http://www.qdfuns.com/tools VScode官网下载 https://code.visualstudio.com/vscode 插件精选 - 献给所有前端工程师https://segmentfault.com/a/1190000006697219 SublimeText官网下载 https://www.sublimetext.com/前端网破解版插件版下载 http://www.qdfuns.com/toolsSublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言Emmet：一个用于提高开发效率的编辑器插件，前身是Zen codingSublimeLinter: 一个提供代码质量检测的插件SublimeTmpl：快速新建指定的模版文件Syntax-highlighting-for-Sass：sass代码高亮插件MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等ApplySyntax: 辅助检测语法插件CTags: Sublime Text Ctags 支持插件, 需要安装 ctagssublime-react: React 代码高亮 Atom官网下载 https://atom.io/ HBuilder官网下载 http://www.dcloud.io/ JS框架 JS FrameworksBackboneBackbone.js API中文文档http://www.css88.com/doc/backbone/ AngularJs中文官方文档https://angular.cn/angularjs中文网http://www.apjs.net/angularjs教程http://www.angularjs.net.cn/Angular 基础入门http://www.cnblogs.com/micua/p/angular-essential.htmlangular-masonry: Masonry 的 AngularJS 插件，用于瀑布流angular-schema-form: 根据 JSON 生成响应的 Form 表单restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resourceng-cordova: Cordova 常用组件的 Angular 版本angular-translate: Angular 的国际化 (I18n)ng-inspector: Chrome 插件，用于调试 Angularangularjs-style-guide: AngularJS 代码风格ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Componentsmaterial: Google Material Design 效果的 Angular 实现angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级angular-filter: 一组有用的 Angular Filtersbindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能 React英文官方文档https://facebook.github.io/react/docs/hello-world.html中文官方文档http://reactjs.cn/react/docs/getting-started-zh-CN.htmlgitbooks手册https://hulufei.gitbooks.io/react-tutorial/content/introduction.html阮一峰react入门http://www.ruanyifeng.com/blog/2015/03/react.html阮一峰React Router入门http://www.ruanyifeng.com/blog/2016/05/react_router.htmlReact Router 中文文档https://react-guide.github.io/react-router-cn/react-redux 中文文档http://cn.redux.js.org/docs/react-redux/index.html阮一峰Redux 入门教程http://www.ruanyifeng.com/blogreact: React 框架源代码react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架react-hot-loader: 实时调整 React 组件效果grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JStouchstonejs: 基于 React 的手机应用前端框架essential-react: 基于 React, ES6, React-Router的一个应用脚手架react-router: React 路由解决方案 Vuevue官方http://cn.vuejs.org/vuex官方http://vuex.vuejs.org/zh-cn/vue-router官方https://router.vuejs.org/zh-cn/ UI框架 UI FrameworksBootstrap最受欢迎的 HTML、CSS 和 JS 框架 http://v3.bootcss.com/ Ionic一款接近原生的Html5移动App开发框架 会html css js就可以开发apphttp://www.ionic.wang/ FoundationFoundation 中文网 迄今为止最好的响应式前端框架http://www.foundcss.com FrozenUI移动端服务的前端框架http://frozenui.github.io/ materializecss基于Material Design的主流前端响应式框架http://www.materializecss.cn/ mui最接近原生APP体验的高性能前端框架http://dev.dcloud.net.cn/mui/ AntDesign和react配合的UI框架https://ant.design eleme和vue配合的UI框架http://element.eleme.io/ JS预处理 JS PreprocessorsTypeScriptTypeScript 入门教程 菜鸟教程http://www.runoob.com/TypeScript中文网https://www.tslang.cn/TypeScript教程gitbookhttps://www.gitbook.com/ CoffeeScriptCoffeeScript 中文http://coffee-script.org/CoffeeScript 实用手册 极客学院http://wiki.jikexueyuan.com/project/coffeescript/ 过程自动化 Process AutomationGruntGrunt中文网http://www.gruntjs.net/ Gulpgulp.js 中文网http://www.gulpjs.com.cn/gulp详细入门教程http://www.ydcss.com/前端构建工具gulpjs的使用介绍及技巧http://www.cnblogs.com/2050/p/4198792.htmlGulp开发教程https://www.w3ctech.com/topic/134 模板引擎 TemplatingHandlebarshandlebarsjs官网http://handlebarsjs.com/Handlebars中文文档http://www.360doc.com/content/Handlebars.js 中文文档http://keenwon.com/992.htmlHandlebars的使用方法文档整理http://www.tuicool.com/articles/fqQFN3 Hamlhaml官方文档https://github.com/haml/hamlhaml入门http://blog.csdn.net/napoay/article/details/50491363 JadeJade 官方的英文文档http://www.w3cplus.com/html/how-to-use-jade.htmlJade的使用http://www.w3cplus.com/html/how-to-use-jade.html带你学习Jade模板引擎视频http://www.imooc.com/learn/259 构建工具 Build ToolsRequireJSRequireJS 英文网http://requirejs.org/RequireJS 中文网http://requirejs.cn/require.js的用法-阮一峰http://www.ruanyifeng.com/blog seajsseajs文档http://seajs.org/docs/SeaJS从入门到原理http://www.tuicool.com/articles/FfEJv2u Browserify官网http://browserify.org/githubhttps://github.com/substack/node-browserify/ WebpackWebpack 中文指南http://webpackdoc.com/webpack的实例http://www.vichily.comwebpack的入门http://www.vichily.com一小时包教会 —— webpack 入门指南http://www.w2bc.com/Article/50764 CSS预处理器 CSS PreprocessorsSasssass入门http://www.w3cplus.com/sassguide/sass参考手册http://sass.bootcss.com/docs/sass-reference/SASS用法指南-阮一峰http://www.ruanyifeng.com/blog/ Lessless中文网http://lesscss.cn/less快速入门http://less.bootcss.com/ stylusstylus中文文档-张鑫旭http://www.zhangxinxu.com/jq/stylus/","categories":[{"name":"前端","slug":"前端","permalink":"https://lzxhh2017.github.io/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://lzxhh2017.github.io/tags/HTML/"},{"name":"JS","slug":"JS","permalink":"https://lzxhh2017.github.io/tags/JS/"}]},{"title":"Nginx+Tomcat搭建集群环境","date":"2018-12-15T14:38:19.000Z","path":"2018/12/15/Nginx-Tomcat搭建集群环境/","text":"前言 Nginx结合tomcat进行集群搭建。Nginx不仅仅是一个反向代理服务器，它本身也可以托管网站，作为Web服务器，进行Http服务处理。 一、Nginx介绍 Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 应用场景： http服务器。Nginx可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 二、tomcat集群 提高服务的性能，例如计算处理能力、并发能力等，以及实现服务的高可用性。 提供项目架构的横向扩展能力，增加集群中的机器就能提高集群的性能。 三、实现步骤 1、安装Nginx，通过https://nginx.org/en/download.html 下载，这里用的版本是nginx-1.14.2，下载解压即可。 2、准备两个tomcat 3、分别修改两个tomcat的启动端口，下面以apache-tomcat-7.0.202为例，打开server.xml 需要修改三处端口号： 123456789&lt;Server port=\"8007\" shutdown=\"SHUTDOWN\"&gt;&lt;Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;&lt;Connector port=\"8011\" protocol=\"AJP/1.3\" redirectPort=\"8443\"/&gt; 4、启动两个tomcat（运行bin文件夹下面的startup.bat），然后在浏览器中访问，查看是否启动正常，这里是修改了/webapps/ROOT路径下的默认页面index.jsp文件，访问如下图所示： 5、访问正常后，进行配置Nginx来实现负载均衡，打开Nginx文件夹中的nginx.conf文件 核心配置如下 6、配置完成后，启动Nginx: 7、浏览器进行访问localhost查看运行状况。（upstream指定了集群服务的各个服务的地址，weight来增加某个服务器的权重，也就意味着请求会被多转发到这个服务器上。）","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://lzxhh2017.github.io/categories/Tomcat/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://lzxhh2017.github.io/tags/Nginx/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://lzxhh2017.github.io/tags/Tomcat/"}]},{"title":"Oracle 11g导出空表、少表的解决方法","date":"2018-12-04T03:32:48.000Z","path":"2018/12/04/Oracle-11g导出空表、少表的解决方法/","text":"前言 Oracle11g有个新特性，这个新特性 “deferred_segment_creation” 含义是段延迟创建，默认是true。如果这个参数设置为true，你新创建了一个Table，并且没有向其中插入数据，那么这个表不会立即分配extend，也就是不占数据空间，即表不分配segment以节省空间，所以这些表也没能导出来。在系统表user_tables中也可以看到segment_treated的字段里是“NO”或者“YES”说明了某张表是否分配了segment。说白了是为了可以节省少量的空间。 解决方法如下： 1、查询该用户下的所有空表 1select table_name from user_tables where NUM_ROWS=0; 2、构建针对空表分配空间的命令语句 1select &apos;alter table &apos;||table_name||&apos; allocate extent;&apos; from user_tables where num_rows=0 or num_rows is null; 查询结果如下所示： 上述代码会产生批量的修改表extent的SQL语句，只需要将其生成的所有sql代码全部执行，就可以给每一张已经存在的表来分配segment。 接着用exp语句导出即可。 1exp system/manager@TEST file=d:\\daochu.dmp","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]},{"title":"Oracle和MySQL递归查询本下级","date":"2018-11-23T11:14:33.000Z","path":"2018/11/23/Oracle和MySQL递归查询本下级/","text":"前言 Oracle 操作(select…start with…connect by…prior);Mysql需要建立函数进行操作。 Oracle数据库结构表如下： 123456789create table regions( region_id number(8) primary key, p_region_id number(10), region_path varchar2(255), region_grade number(8), local_name varchar2(100), zipcode varchar2(20), cod varchar2(4)); 查找一个节点下面的所有节点，其中region_id是传入的参数： 1SELECT * FROM regions START WITH region_id = 1 connect BY prior region_id = p_region_id; 查询结果如下所示： MySql数据库创建表 1234567891011DROP TABLE IF EXISTS `es_regions`;CREATE TABLE `regions` ( `region_id` int(10) NOT NULL AUTO_INCREMENT, `p_region_id` int(10) DEFAULT NULL, `region_path` varchar(255) DEFAULT NULL, `region_grade` int(8) DEFAULT NULL, `local_name` varchar(100) NOT NULL, `zipcode` varchar(20) DEFAULT NULL, `cod` varchar(4) DEFAULT NULL, PRIMARY KEY (`region_id`)) ENGINE=InnoDB AUTO_INCREMENT=489 DEFAULT CHARSET=utf8; 利用find_in_set()函数和group_concat()函数实现递归查询： 123456789101112131415161718DROP FUNCTION IF EXISTS querychild;SET GLOBAL log_bin_trust_function_creators = 1;DELIMITER $$CREATE FUNCTION querychild(param INT)RETURNS VARCHAR(4000)BEGINDECLARE temp VARCHAR(4000);DECLARE sname VARCHAR(4000);SET temp = &apos;$&apos;;SET sname = CAST(param AS CHAR);WHILE sname IS NOT NULL DOSET temp = CONCAT(temp,&apos;,&apos;,sname);SELECT GROUP_CONCAT(region_id) INTO sname FROM regions WHERE FIND_IN_SET(p_region_id,sname)&gt;0;END WHILE;RETURN temp;END $$ 调用方式： 1SELECT * FROM regions WHERE FIND_IN_SET(region_id, querychild(1)); 查询结果如下所示：","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lzxhh2017.github.io/tags/MySQL/"}]},{"title":"Oracle数据库初始化脚本","date":"2018-11-21T12:56:30.000Z","path":"2018/11/21/Oracle数据库初始化脚本/","text":"前言 Oracle数据库初始化：创建表空间；创建用户并赋予权限；数据导入。 创建表空间123create tablespace mhpt datafile &apos;E:\\htzqjj\\ts_data.ora&apos; size 1000m;select file_id from dba_data_files where tablespace_name=&apos;MHPT&apos;;alter database datafile 9 autoextend on next 10M; --9是之前查出的file_id; 创建用户并赋予权限1234567891011121314grant create any index to NAME;grant create database link to NAME;grant create procedure to NAME;grant create sequence to NAME;grant create table to NAME;grant create view to NAME;grant debug connect session to NAME;grant delete any table to NAME;grant select any table to NAME;grant unlimited tablespace to NAME;grant update any table to NAME;grant dba to NAME;grant connect to NAME;grant resource to NAME; 数据导入1imp mhpt/mhpt2@127.0.0.1/orcl file=D:\\mhpt_20170726.dmp log=D:\\temp\\log.txt full=y ignore=y","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]}]