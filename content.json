[{"title":"Nginx+Tomcat搭建集群环境","date":"2019-04-05T14:38:19.000Z","path":"2019/04/05/Nginx-Tomcat搭建集群环境/","text":"Nginx结合tomcat进行集群搭建。Nginx不仅仅是一个反向代理服务器，它本身也可以托管网站，作为Web服务器，进行Http服务处理。 一、Nginx介绍 Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 应用场景： http服务器。Nginx可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 二、tomcat集群 提高服务的性能，例如计算处理能力、并发能力等，以及实现服务的高可用性。 提供项目架构的横向扩展能力，增加集群中的机器就能提高集群的性能。 三、实现步骤 1、安装Nginx，通过https://nginx.org/en/download.html 下载，这里用的版本是nginx-1.14.2，下载解压即可。 2、准备两个tomcat 3、分别修改两个tomcat的启动端口，下面以apache-tomcat-7.0.202为例，打开server.xml 需要修改三处端口号： 123456789&lt;Server port=\"8007\" shutdown=\"SHUTDOWN\"&gt;&lt;Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;&lt;Connector port=\"8011\" protocol=\"AJP/1.3\" redirectPort=\"8443\"/&gt; 4、启动两个tomcat（运行bin文件夹下面的startup.bat），然后在浏览器中访问，查看是否启动正常，这里是修改了/webapps/ROOT路径下的默认页面index.jsp文件，访问如下图所示： 5、访问正常后，进行配置Nginx来实现负载均衡，打开Nginx文件夹中的nginx.conf文件 核心配置如下 6、配置完成后，启动Nginx: 7、浏览器进行访问localhost查看运行状况。（upstream指定了集群服务的各个服务的地址，weight来增加某个服务器的权重，也就意味着请求会被多转发到这个服务器上。）","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://lzxhh2017.github.io/categories/Tomcat/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://lzxhh2017.github.io/tags/Nginx/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://lzxhh2017.github.io/tags/Tomcat/"}]},{"title":"Oracle 11g导出空表、少表的解决方法","date":"2019-04-04T03:32:48.000Z","path":"2019/04/04/Oracle-11g导出空表、少表的解决方法/","text":"Oracle11g有个新特性，这个新特性 “deferred_segment_creation” 含义是段延迟创建，默认是true。如果这个参数设置为true，你新创建了一个Table，并且没有向其中插入数据，那么这个表不会立即分配extend，也就是不占数据空间，即表不分配segment以节省空间，所以这些表也没能导出来。在系统表user_tables中也可以看到segment_treated的字段里是“NO”或者“YES”说明了某张表是否分配了segment。说白了是为了可以节省少量的空间。 解决方法如下： 1、查询该用户下的所有空表 1select table_name from user_tables where NUM_ROWS=0; 2、构建针对空表分配空间的命令语句 1select &apos;alter table &apos;||table_name||&apos; allocate extent;&apos; from user_tables where num_rows=0 or num_rows is null; 查询结果如下所示： 上述代码会产生批量的修改表extent的SQL语句，只需要将其生成的所有sql代码全部执行，就可以给每一张已经存在的表来分配segment。 接着用exp语句导出即可。 1exp system/manager@TEST file=d:\\daochu.dmp","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]},{"title":"Oracle和MySQL递归查询本下级","date":"2019-04-03T11:14:33.000Z","path":"2019/04/03/Oracle和MySQL递归查询本下级/","text":"Oracle 操作(select…start with…connect by…prior);Mysql需要建立函数进行操作。 Oracle数据库结构表如下： 123456789create table regions( region_id number(8) primary key, p_region_id number(10), region_path varchar2(255), region_grade number(8), local_name varchar2(100), zipcode varchar2(20), cod varchar2(4)); 查找一个节点下面的所有节点，其中region_id是传入的参数： 1SELECT * FROM regions START WITH region_id = 1 connect BY prior region_id = p_region_id; 查询结果如下所示： MySql数据库创建表 1234567891011DROP TABLE IF EXISTS `es_regions`;CREATE TABLE `regions` ( `region_id` int(10) NOT NULL AUTO_INCREMENT, `p_region_id` int(10) DEFAULT NULL, `region_path` varchar(255) DEFAULT NULL, `region_grade` int(8) DEFAULT NULL, `local_name` varchar(100) NOT NULL, `zipcode` varchar(20) DEFAULT NULL, `cod` varchar(4) DEFAULT NULL, PRIMARY KEY (`region_id`)) ENGINE=InnoDB AUTO_INCREMENT=489 DEFAULT CHARSET=utf8; 利用find_in_set()函数和group_concat()函数实现递归查询： 123456789101112131415161718DROP FUNCTION IF EXISTS querychild;SET GLOBAL log_bin_trust_function_creators = 1;DELIMITER $$CREATE FUNCTION querychild(param INT)RETURNS VARCHAR(4000)BEGINDECLARE temp VARCHAR(4000);DECLARE sname VARCHAR(4000);SET temp = &apos;$&apos;;SET sname = CAST(param AS CHAR);WHILE sname IS NOT NULL DOSET temp = CONCAT(temp,&apos;,&apos;,sname);SELECT GROUP_CONCAT(region_id) INTO sname FROM regions WHERE FIND_IN_SET(p_region_id,sname)&gt;0;END WHILE;RETURN temp;END $$ 调用方式： 1SELECT * FROM regions WHERE FIND_IN_SET(region_id, querychild(1)); 查询结果如下所示：","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/categories/Oracle/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lzxhh2017.github.io/tags/MySQL/"},{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]},{"title":"Oracle数据库初始化脚本","date":"2019-04-02T12:56:30.000Z","path":"2019/04/02/Oracle数据库初始化脚本/","text":"Oracle数据库初始化：创建表空间；创建用户并赋予权限；数据导入。 创建表空间123create tablespace mhpt datafile &apos;E:\\htzqjj\\ts_data.ora&apos; size 1000m;select file_id from dba_data_files where tablespace_name=&apos;MHPT&apos;;alter database datafile 9 autoextend on next 10M; --9是之前查出的file_id; 创建用户并赋予权限1234567891011121314grant create any index to NAME;grant create database link to NAME;grant create procedure to NAME;grant create sequence to NAME;grant create table to NAME;grant create view to NAME;grant debug connect session to NAME;grant delete any table to NAME;grant select any table to NAME;grant unlimited tablespace to NAME;grant update any table to NAME;grant dba to NAME;grant connect to NAME;grant resource to NAME; 数据导入1imp mhpt/mhpt2@127.0.0.1/orcl file=D:\\mhpt_20170726.dmp log=D:\\temp\\log.txt full=y ignore=y","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]}]