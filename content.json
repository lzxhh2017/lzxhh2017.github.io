[{"title":"Java设计模式之原型模式","date":"2019-03-18T12:08:14.000Z","path":"2019/03/18/Java设计模式之原型模式/","text":"前言 原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。在原型模式中，所发动创建的对象通过请求原型对象来拷贝原型对象自己来实现创建过程，当然所发动创建的对象需要知道原型对象的类型。这里也就是说所发动创建的对象只需要知道原型对象的类型就可以获得更多的原型实例对象，至于这些原型对象时如何创建的根本不需要关心。 UML图如下所示： 原型模式主要包含如下三个角色： Prototype：抽象原型类。声明克隆自身的接口。 ConcretePrototype：具体原型类。实现克隆的具体操作。 Client：客户类。让一个原型克隆自身，从而获得一个新的对象。 java中复制通过clone()实现的。clone中涉及深、浅复制。深、浅复制的概念如下： 浅复制被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址。 深复制被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。 浅复制实现：Address 12345678910111213141516171819202122232425public class Address &#123; private String province;//省 private String city;//市 public Address(String province, String city) &#123; this.province = province; this.city = city; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125;&#125; Prototype 1234567891011121314151617181920212223242526272829public class Prototype implements Cloneable &#123; private String name;//名字 private Address address; public Prototype(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125;&#125; Client 123456789101112public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Prototype p1 = new Prototype(\"张三\"); p1.setAddress(new Address(\"江西\", \"赣州\")); p1.setName(\"张三\"); Prototype p2 = (Prototype) p1.clone(); p2.setName(\"李四\"); p2.getAddress().setProvince(\"北京\"); System.out.println(p2.getName() + p2.getAddress().getProvince()); System.out.println(p1.getName() + p1.getAddress().getProvince()); &#125;&#125; 输出结果如下： 可以看出来对象并复制，依然使用的是同一个引用。其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址。 深复制实现Address 12345678910111213141516171819202122232425262728293031323334353637public class Address implements Cloneable &#123; private String province;//省 private String city;//市 public Object clone() &#123; Address address = null; try &#123; address = (Address) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return address; &#125; public Address(String province, String city) &#123; this.province = province; this.city = city; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125;&#125; Prototype 123456789101112131415161718192021222324252627282930public class Prototype implements Cloneable &#123; private String name;//名字 private Address address; public Prototype(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); proto.address=(Address) address.clone(); return proto; &#125;&#125; Client 123456789101112public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Prototype p1 = new Prototype(\"张三\"); p1.setAddress(new Address(\"江西\", \"赣州\")); p1.setName(\"张三\"); Prototype p2 = (Prototype) p1.clone(); p2.setName(\"李四\"); p2.getAddress().setProvince(\"北京\"); System.out.println(p2.getName() + p2.getAddress().getProvince()); System.out.println(p1.getName() + p1.getAddress().getProvince()); &#125;&#125; 输出结果如下： 总结原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用，下面对该模式的使用效果和适用情况进行简单的总结。 优点(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 (2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。 (3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 (4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。 缺点(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 (2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 应用场景(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 (2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。 (3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"原型模式","slug":"原型模式","permalink":"https://lzxhh2017.github.io/tags/原型模式/"}]},{"title":"TCP协议中的三次握手和四次挥手","date":"2019-03-16T11:58:29.000Z","path":"2019/03/16/TCP协议中的三次握手和四次挥手/","text":"前言 TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于IP的传输层协议。 TCP连接和关闭的过程图解 TCP三次握手 首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。（A、B关闭状态CLOSED——B收听状态LISTEN——A同步已发送状态SYN-SENT——B同步收到状态SYN-RCVD——A、B连接已建立状态ESTABLISHED）。 B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应。 第一次握手：A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出连接请求报文段，（首部的同步位SYN=1，初始序号seq=x），（SYN=1的报文段不能携带数据）但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态； 第二次握手：B收到连接请求报文段后，如同意建立连接，则向A发送确认，在确认报文段中（SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），测试TCP服务器进程进入SYN-RCVD（同步收到）状态； 第三次握手：TCP客户进程收到B的确认后，要向B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）； 当B收到A的确认后，也进入ESTABLISHED状态。 三次握手过程： 第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认； 第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量； 第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。 为什么A还要发送一次确认呢？可以二次握手吗？主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。 Server端易受到SYN攻击？服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。 四次挥手 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。（A、B连接建立状态ESTABLISHED——A终止等待1状态FIN-WAIT-1——B关闭等待状态CLOSE-WAIT——A终止等待2状态FIN-WAIT-2——B最后确认状态LAST-ACK——A时间等待状态TIME-WAIT——B、A关闭状态CLOSED） A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。 B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。 A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。 B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。 A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。 四次挥手过程：起初A和B处于ESTABLISHED状态——》A发出连接释放报文段并处于FIN-WAIT-1状态——》B发出确认报文段且进入CLOSE-WAIT状态——》A收到确认后，进入FIN-WAIT-2状态，等待B的连接释放报文段——》B没有要向A发出的数据，B发出连接释放报文段且进入LAST-ACK状态——》A发出确认报文段且进入TIME-WAIT状态——》B收到确认报文段后进入CLOSED状态——》A经过等待计时器时间2MSL后，进入CLOSED状态。 为什么A在TIME-WAIT状态必须等待2MSL的时间？MSL最长报文段寿命Maximum Segment Lifetime，MSL=2。 保证A发送的最后一个ACK报文段能够到达B。 防止“已失效的连接请求报文段”出现在本连接中。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。 A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 为什么连接的时候是三次握手，关闭的时候却是四次握手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"TCPIP","slug":"后端/TCPIP","permalink":"https://lzxhh2017.github.io/categories/后端/TCPIP/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://lzxhh2017.github.io/tags/TCP/"},{"name":"三次握手","slug":"三次握手","permalink":"https://lzxhh2017.github.io/tags/三次握手/"},{"name":"四次挥手","slug":"四次挥手","permalink":"https://lzxhh2017.github.io/tags/四次挥手/"}]},{"title":"重载“+”与StringBuilder","date":"2019-03-15T05:45:09.000Z","path":"2019/03/15/重载“-”与StringBuilder/","text":"前言 String对象是不可变的。涉及String值的操作都是创建了一个全新的String对象，原来的String值一点也没有变。用于String的“+”与“+=”是Java中仅有的两个重载过的操作符，并不允许程序员重载任何操作符。 操作符“+”可以用来连接String： 1234567public class Concatenation&#123; public static void main(String args[])&#123; String mango = &quot;mango&quot;; String s = &quot;abc&quot; + mango + &quot;def&quot; + 47; System.out.println(s); &#125; &#125; 接着我们用JDK自带的工具javap进行反编译以上代码，命令如下： javac Concatenation.javajavap -c Concatenation 从上图可以看出编译器创建了一个StringBuilder对象，用以构造最终的String，并为每一个字符串调用了一次StringBuilder的append()方法，总计四次。最后调用toString()生成结果。 编译器对String的优化12345678910111213141516public class WhitherStringBuilder &#123; public String implicit(String[] fields) &#123; String result = &quot;&quot;; for (int i = 0; i &lt; fields.length; i++) result += fields[i]; return result; &#125; public String explicit(String[] fields) &#123; StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; fields.length; i++) result.append(fields[i]); return result.toString(); &#125; &#125; 接着用反编译器进行编译一下，首先是implicit()方法： 从上图可以注意到从第8行到第35行是一个循环体，每循环一次，都会创建一个新的StringBuilder对象。接着来看下explicit()方法对应的字节码： 从上图可以看出不仅循环部分的代码更简短、更简单，而且它只生成了一个StringBuilder对象。 StringBuilder特点可以为StringBuilder预先指定大小，如果知道最终的字符串长度，可以预先指定StringBuilder的大小，以避免多次重新分配缓冲。 如果要在toString()方法中使用循环的话，最好自己创建一个StringBuidler对象。 StringBuidler提供了丰富而全面的方法，包括insert()，replace()， substring()，reverse()，最常用的方法是append()和toString()方法。 StringBuilder线程不安全，效率高，StringBuffer 线程安全，效率低。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"String","slug":"String","permalink":"https://lzxhh2017.github.io/tags/String/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://lzxhh2017.github.io/tags/StringBuilder/"}]},{"title":"单点登录原理与简单实现","date":"2019-03-14T11:35:10.000Z","path":"2019/03/14/单点登录原理与简单实现/","text":"前言 随着企业的发展，用到的系统随之增多，用户在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于用户来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。 单系统登录机制1、http无状态协议web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系。 但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 2、会话机制浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联。 服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式： 请求参数 cookie 将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息。 tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图所示： 3、登录状态有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下： 12HttpSession session = request.getSession();session.setAttribute(\"isLogin\", true); 用户再次访问时，tomcat在会话对象中查看登录状态： 12HttpSession session = request.getSession();session.getAttribute(\"isLogin\"); 实现了登录状态的浏览器请求服务器模型如下图描述： 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 多系统的复杂性web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样： web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？ 单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。 既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。 然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。 因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 单点登录什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。 1、登录相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明： 下面对上图简要描述： 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌 sso认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统2的受保护资源 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌 系统2拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统2 系统2使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系： 局部会话存在，全局会话一定存在 全局会话存在，局部会话不一定存在 全局会话销毁，局部会话必须销毁 2、注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明： sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作： 用户向系统1发起注销请求 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求 sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址 sso认证中心向所有注册系统发起注销请求 各注册系统接收sso认证中心的注销请求，销毁局部会话 sso认证中心引导用户至登录页面 部署图单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述： sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以。 实现只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server） sso-client 拦截子系统未登录用户请求，跳转至sso认证中心 接收并存储sso认证中心发送的令牌 与sso-server通信，校验令牌的有效性 建立局部会话 拦截用户注销请求，向sso认证中心发送注销请求 接收sso认证中心发出的注销请求，销毁局部会话 sso-server 验证用户的登录信息 创建全局会话 创建授权令牌 与sso-client通信发送令牌 校验sso-client令牌有效性 系统注册 接收sso-client注销请求，注销所有会话 1、sso-client拦截未登录请求java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截。 123456789101112public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; HttpSession session = req.getSession(); if (session.getAttribute(\"isLogin\")) &#123; chain.doFilter(request, response); return; &#125; //跳转至sso认证中心 res.sendRedirect(\"sso-server-url-with-system-url\");&#125; 2、sso-server拦截未登录请求拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样。 3、sso-server验证用户登录信息用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”。 123456@RequestMapping(\"/login\")public String login(String username, String password, HttpServletRequest req) &#123; this.checkLoginInfo(username, password); req.getSession().setAttribute(\"isLogin\", true); return \"success\";&#125; 4、sso-server创建授权令牌授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子： 1String token = UUID.randomUUID().toString(); 5、sso-client取得令牌并校验sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行： 1234567891011// 请求附带token参数String token = req.getParameter(\"token\");if (token != null) &#123; // 去sso认证中心校验token boolean verifyResult = this.verify(\"sso-server-verify-url\", token); if (!verifyResult) &#123; res.sendRedirect(\"sso-server-url\"); return; &#125; chain.doFilter(request, response);&#125; verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档。 12HttpPost httpPost = new HttpPost(\"sso-server-verify-url-with-token\");HttpResponse httpResponse = httpClient.execute(httpPost); 6、sso-server接收并处理校验令牌请求用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）。 令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。 令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。 7、sso-client校验令牌成功创建局部会话令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行： 123if (verifyResult) &#123; session.setAttribute(\"isLogin\", true);&#125; sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求。 8、注销过程用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求。 1234String logout = req.getParameter(\"logout\");if (logout != null) &#123; this.ssoServer.logout(token);&#125; sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话。 12345678@RequestMapping(\"/logout\")public String logout(HttpServletRequest req) &#123; HttpSession session = req.getSession(); if (session != null) &#123; session.invalidate();//触发LogoutListener &#125; return \"redirect:/\";&#125; sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销。 12345678public class LogoutListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent event) &#123;&#125; @Override public void sessionDestroyed(HttpSessionEvent event) &#123; //通过httpClient向所有注册系统发送注销请求 &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"单点登录","slug":"单点登录","permalink":"https://lzxhh2017.github.io/tags/单点登录/"},{"name":"cookie","slug":"cookie","permalink":"https://lzxhh2017.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://lzxhh2017.github.io/tags/session/"},{"name":"sso","slug":"sso","permalink":"https://lzxhh2017.github.io/tags/sso/"}]},{"title":"Java获取两个日期之间的日期集合","date":"2019-03-13T11:14:00.000Z","path":"2019/03/13/Java获取两个日期之间的日期集合/","text":"具体实现如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * String转日期 * * @param strDate * @return */public static Date strToDate(String strDate) &#123; SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\"); ParsePosition pos = new ParsePosition(0); Date strtodate = formatter.parse(strDate, pos); return strtodate;&#125;/** * 日期转String * * @param dateDate * @return */public static String dateToStr(Date dateDate) &#123; SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\"); String dateString = formatter.format(dateDate); return dateString;&#125;/** * 获取两日期之间的日期 * * @param beginDate * @param endDate * @return */@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public static Map&lt;String, String&gt; getDatesBetweenTwoDate(Date beginDate, Date endDate) &#123; Map map = new HashMap(); String begin = dateToWeek(beginDate); map.put(dateToStr(beginDate), begin); Calendar cal = Calendar.getInstance(); // 使用给定的 Date 设置此 Calendar 的时间 cal.setTime(beginDate); boolean bContinue = true; while (bContinue) &#123; // 根据日历的规则，为给定的日历字段添加或减去指定的时间量 cal.add(Calendar.DAY_OF_MONTH, 1); // 测试此日期是否在指定日期之后 if (endDate.after(cal.getTime())) &#123; String week = dateToWeek(cal.getTime()); map.put(dateToStr(cal.getTime()), week); &#125; else &#123; break; &#125; &#125; String end = dateToWeek(endDate); map.put(dateToStr(endDate), end);// 把结束时间加入集合 Map&lt;String, String&gt; resultMap = sortMapByKey(map); return resultMap;&#125;/** * 给map集合排序，重组map * * @param map * @return */public static Map&lt;String, String&gt; sortMapByKey(Map&lt;String, String&gt; map) &#123; if (map == null || map.isEmpty()) &#123; return null; &#125; Map&lt;String, String&gt; sortMap = new TreeMap&lt;String, String&gt;(new MapKeyComparator()); sortMap.putAll(map); return sortMap;&#125;public static String dateToWeek(Date datetime) &#123; String[] weekDays = &#123; \"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\" &#125;; Calendar cal = Calendar.getInstance(); // 获得一个日历 cal.setTime(datetime); int w = cal.get(Calendar.DAY_OF_WEEK) - 1; // 指示一个星期中的某天。 if (w &lt; 0) w = 0; return weekDays[w];&#125;public class MapKeyComparator implements Comparator&lt;String&gt;&#123; @Override public int compare(String str1, String str2) &#123; // TODO Auto-generated method stub return str1.compareTo(str2); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"Date","slug":"Date","permalink":"https://lzxhh2017.github.io/tags/Date/"}]},{"title":"Java设计模式之备忘录模式","date":"2019-03-12T10:38:33.000Z","path":"2019/03/12/Java设计模式之备忘录模式/","text":"前言 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复至原先保存的状态。 备忘录模式涉及角色 Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。 Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。 Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。 UML结构图如下所示： 案例场景 我们都玩过魔塔这个游戏，里面的角色有生命值、攻击力和层数的数值，每上一层数值都会发生变化，当打怪时感觉自己打不过时可以进行存档。 具体实现代码：备忘录接口 123public interface IMemento &#123;&#125; 管理者 123456789101112131415161718192021222324252627public class MementoCaretaker &#123; private HashMap&lt;String, IMemento&gt; mementoMap; public MementoCaretaker() &#123; mementoMap = new HashMap&lt;String, IMemento&gt;(); &#125; /** * 获取 * * @param name * @return */ public IMemento retrieveMemento(String name) &#123; return mementoMap.get(name); &#125; /** * 赋值方法 * * @param name * @param memento */ public void saveMemento(String name, IMemento memento) &#123; this.mementoMap.put(name, memento); &#125;&#125; 发起者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Originator1 &#123; private HashMap&lt;String, String&gt; state; public Originator1() &#123; state = new HashMap(); &#125; public IMemento createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(IMemento memento) &#123; state = ((Memento) memento).getState(); &#125; public void showState() &#123; System.out.println(\"now state:\" + state.toString()); &#125; public void testState1() &#123; state.put(\"血量\", \"1000\"); state.put(\"攻击力\", \"500\"); state.put(\"层数\", \"1\"); &#125; public void testState2() &#123; state.put(\"血量\", \"3500\"); state.put(\"攻击力\", \"1500\"); state.put(\"层数\", \"10\"); &#125; private class Memento implements IMemento &#123; private HashMap&lt;String, String&gt; state; private Memento(HashMap state) &#123; this.state = new HashMap(state); &#125; private HashMap getState() &#123; return state; &#125; private void setState(HashMap state) &#123; this.state = state; &#125; &#125;&#125; 测试类 12345678910111213141516public class MementoTest &#123; public static void main(String[] args) &#123; MementoCaretaker mementoCaretaker = new MementoCaretaker(); Originator1 originator1 = new Originator1(); System.out.println(\"发起者originator1\"); originator1.testState1(); originator1.showState(); mementoCaretaker.saveMemento(\"originator\", originator1.createMemento()); originator1.testState2(); originator1.showState(); originator1.restoreMemento(mementoCaretaker.retrieveMemento(\"originator\")); originator1.showState(); &#125;&#125; 测试结果如下所示： 以上便是备忘录模式的具体实现。 总结备忘录模式可以把发起人内部信息对象屏蔽起来，从而可以达到保持封装的边界。当发起人的状态出现问题时，可以很轻松的恢复。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"备忘录模式","slug":"备忘录模式","permalink":"https://lzxhh2017.github.io/tags/备忘录模式/"}]},{"title":"Snowflake ID生成算法","date":"2019-03-11T12:33:24.000Z","path":"2019/03/11/SnowflakeID生成算法/","text":"前言 Snowflake是Twitter设计的一套自增ID生成算法，目的是为了能够在每秒或者每毫秒内产生成千上万唯一不重复的ID（消息请求）。 Snowflake生成的ID为一个64bit数，结构示意如下： 以上各部分之间以-分隔开，总共分为五大部分，每个部分解释如下： 表格 代表 含义 位数 最多可用取数 sign 符号位 1 timestamp 相对时间长度 41 1&lt;&lt;41 = 2199023255552 datacenter 数据中心编号 5 1&lt;&lt;5 = 32 machine 服务器编号 5 1&lt;&lt;5 = 32 sequence 序列号 12 1&lt;&lt;12=4096 sign：默认为0，代表无符号数； timestamp：单位为 ms，这是一个相对时间长度，也可以理解为工作时间戳与开始时间戳的差值，意味着我们可以从一个不大于当前时间节点的任意一个时间为起点算起。假设从当前时间开始计算，该算法可以一直使用(1&lt;&lt;41)/(365天24小时60分60秒1000毫秒) = 69 年； datacenter：从0到31编号，每 ms 内最多可以有32个 datacenter 同时工作； machine：从0到31编号，每 ms 内每个 datacenter 最多可以有32个 machine 同时工作； sequence：从0到4096，每 ms 内每个 datacenter 每台 machine 最多可以产生4096个 sequence。 具体代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class SnowflakeId &#123; //开始时间截 (2019-03-11) private final long twepoch = 1552233600000L; //机器id所占的位数 private final long workerIdBits = 5L; //数据标识id所占的位数 private final long datacenterIdBits = 5L; //支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); //支持的最大数据标识id，结果是31 private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); //序列在id中占的位数 private final long sequenceBits = 12L; //机器ID向左移12位 private final long workerIdShift = sequenceBits; //数据标识id向左移17位(12+5) private final long datacenterIdShift = sequenceBits + workerIdBits; //时间截向左移22位(5+5+12) private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; //生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); //工作机器ID(0~31) private long workerId; //数据中心ID(0~31) private long datacenterId; //毫秒内序列(0~4095) private long sequence = 0L; //上次生成ID的时间截 private long lastTimestamp = -1L; /** * 构造函数 * * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeId(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException( String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException( String.format(\"datacenter Id can't be greater than %d or less than 0\", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** * 获得下一个ID (该方法是线程安全的) * * @return SnowflakeId */ public synchronized long nextId() &#123; long timestamp = timeGen(); // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format( \"Clock moved backwards. Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp)); &#125; // 如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; // 毫秒内序列溢出 if (sequence == 0) &#123; // 阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; // 时间戳改变，毫秒内序列重置 else &#123; sequence = 0L; &#125; // 上次生成ID的时间截 lastTimestamp = timestamp; // 移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; &#125; /** * 阻塞到下一个毫秒，直到获得新的时间戳 * * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) &#123; long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen(); &#125; return timestamp; &#125; /** * 返回以毫秒为单位的当前时间 * * @return 当前时间(毫秒) */ protected long timeGen() &#123; return System.currentTimeMillis(); &#125; public static void main(String[] args) throws InterruptedException &#123; final SnowflakeId idGenerator = new SnowflakeId(0, 1); // 线程池并行执行10000次ID生成 ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10000; i++) &#123; executorService.execute(new Runnable() &#123; @Override public void run() &#123; long id = idGenerator.nextId(); System.out.println(id); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"Snowflake","slug":"Snowflake","permalink":"https://lzxhh2017.github.io/tags/Snowflake/"}]},{"title":"用户密码保存加密场景","date":"2019-03-10T12:14:52.000Z","path":"2019/03/10/用户密码保存加密场景/","text":"前言 在我们程序开发当中，保护用户账号密码和资料是非常重要的。手机和网络成为了我们生活中不可或缺的必需品。我们把认为重要的东西都存放在手机或者电脑里面，一旦这些设备丢失的话，后果是不堪设想的。所以，数据加密具有非常重大的意义，可以避免设备丢失对您造成的损失。 保证用户账号密码的安全十分重要，本文介绍的是在时间复杂度和空间复杂度上增加破解的难度。 固定盐：固定盐就是使用输定数据参与摘要计算，好处是实现简单，缺点是安全性不足，一旦“盐”被泄露会影响所有用户。 随机盐：每次计算摘要计算都使用的盐，比如按照一定的规则，针对每一个用户生成一个随机盐，一个用户使用同一个盐，不同之间的用户“盐”不用，这样即使一个用户密码被破解，也不影响其他用户,另外在用户重置密码时也需要重新生成盐。 循环hash，延长计算时间，增加破解难度，PBKDF2, bcrypt, scrypt 就是这类的算饭。由于 MD5，SHA系列算法都是运算比较快的算法，随着硬件的发展，单次摘要计算获得结果也变得容易被破解，可以说只是时间问题，为了应对这种问题，引入了“拉伸”概念，就是通过多次循环 hash 加密算法变慢（在RFC2898文案中推荐 推荐不小于1000次），增加攻击者的时间成本，使得暴力破解变得非常困难。 具体代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.java.hash;import org.apache.commons.codec.binary.Base64;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.spec.InvalidKeySpecException;public class UserPasswordHash &#123; // 生成摘要长度 512 位，理论上越长的摘要越难破解。 private static final int HASH_BIT_SIZE = 512; // 迭代次数，按照 在RFC2898文案中推荐 的建议，不少以100次 private static final int ITERATIONS = 2000; // 盐的长度，按照 RFC2898 中的建议，盐的长度不低于64位 private static final int SALT_BIT_SIZE = 64; // 创建密码摘要 public static String genPasswordHash(String password, String salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), Base64.decodeBase64(salt), ITERATIONS, HASH_BIT_SIZE); SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA512\"); byte[] hash = skf.generateSecret(spec).getEncoded(); return Base64.encodeBase64String(hash); &#125; // 生成随机盐 public static String genRandomSalt() &#123; byte[] salt = new byte[SALT_BIT_SIZE]; SecureRandom rand = new SecureRandom(); rand.nextBytes(salt); return Base64.encodeBase64String(salt); &#125; // 验证密码 public static boolean verify(String password, String salt, String passHash) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; String hash = genPasswordHash(password, salt); return hash.equals(passHash); &#125; public static void savePasswordDemo(String passwordHash, String salt) &#123; //密码Hash 和 salt 同时存储 &#125; public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; //原始密码 String weakPassword = \"123456\"; //生成随机盐 String salt = genRandomSalt(); //经过加盐后的密码摘要 String passwordHash = genPasswordHash(weakPassword, salt); //同时储存密码hash和盐 savePasswordDemo(passwordHash, salt); //验证密码 boolean resualt = verify(weakPassword, salt, passwordHash); System.out.println(resualt); &#125;&#125; 输出结果如下所示：","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://lzxhh2017.github.io/tags/hash/"}]},{"title":"Java设计模式之迪米特法则","date":"2019-03-09T02:07:45.000Z","path":"2019/03/09/Java设计模式之迪米特法则/","text":"前言 迪米特法则（LoD），又称最少知识原则，定义：每一个类都应当尽量降低成员的访问权限（只和自己有直接关系的人发生通信，不与陌生人发送通信）。迪米特法则的根本思想是类之间解耦，弱耦合，耦合越弱，复用性则越高。 迪米特法则设计规则 在类的划分上，应该创建弱耦合的类，耦合越弱，复用性越高。 在类的结构设计上，每个类都应该降低成员的访问权限。 在类的设计上，只要有可能，一个类应当设计成不变的类。 在对其他类的引用上，一个对象对其它对象的引用应当降到最低； 尽量降低类的访问权限。 代码示例大话设计模式中小菜入职第一天办理入职手续，定义IT部门接口，小李和小张实现接口，其他部门也可以调用。代码如下所示： IT部门接口1234567public interface ITDepartment &#123; public void installSystem();//装系统 public void assignAccount();//分配账号&#125; IT部门小李1234567891011public class Xiaoli implements ITDepartment &#123; @Override public void installSystem() &#123; System.out.println(&quot;小李在帮小菜安装系统&quot;); &#125; @Override public void assignAccount() &#123; System.out.println(&quot;小李在帮小菜配置账号&quot;); &#125;&#125; IT部门小张1234567891011public class Xiaozhang implements ITDepartment &#123; @Override public void installSystem() &#123; System.out.println(&quot;小张在帮小菜安装系统&quot;); &#125; @Override public void assignAccount() &#123; System.out.println(&quot;小张在帮小菜配置账号&quot;); &#125;&#125; 其他部门1234567public class OtherDepartment &#123; public void doThing(ITDepartment itDepartment) &#123; itDepartment.installSystem(); itDepartment.assignAccount(); &#125;&#125; 测试类12345678910public class Test &#123; public static void main(String[] args)&#123; ITDepartment it1 = new Xiaoli(); ITDepartment it2 = new Xiaozhang(); OtherDepartment otherDepartment = new OtherDepartment(); otherDepartment.doThing(it1); otherDepartment.doThing(it2); &#125;&#125; 输出结果如下所示： 总结迪米特法则体现在类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，也不会对有关系的类造成波及。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"迪米特法则","slug":"迪米特法则","permalink":"https://lzxhh2017.github.io/tags/迪米特法则/"}]},{"title":"LinkedHashMap实现缓存及LRU算法","date":"2019-03-08T12:03:04.000Z","path":"2019/03/08/LinkedHashMap实现缓存及LRU算法/","text":"前言 平时的项目中，为了提高运行速度，我们都会用到缓存，而缓存内存容量是有限的，那么应该如何实现呢？在Java中提供了一个自动清理最老元素的LinkedHashMap类，通过重写removeEldestEntry(java.util.Map.Entryeldest)这个方法，当插入元素时，该方法会判断是否达到缓存上限，如果达到缓存的上限，则会移除掉最老的元素。 具体代码如下所示： 12345678910111213141516171819202122232425public class LruLinkedHashMapCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private final int maxCapacity; private static final float DEFAULT_LOAD_FACTOR = 0.75f; public LruLinkedHashMapCache(int maxCapacity) &#123; super(maxCapacity, DEFAULT_LOAD_FACTOR, true); this.maxCapacity = maxCapacity; &#125; @Override protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) &#123; // 当达到预设缓存上限时删除最老元素 return this.size() &gt; maxCapacity; &#125; public static void main(String[] args)&#123; LruLinkedHashMapCache&lt;String, String&gt; cache = new LruLinkedHashMapCache&lt;String, String&gt;(3); cache.put(\"a\", \"a\"); cache.put(\"b\", \"b\"); cache.put(\"c\", \"c\"); cache.put(\"a\", \"a\"); cache.put(\"d\", \"d\"); System.out.println(cache); &#125;&#125; 输出结果如下： 从输出结果可以看出，当缓存满了的时候，就会remove掉最远使用的那个元素。LinkedHashMap默认的元素顺序是put的顺序，LinkedHashMap的get()方法除了返回元素之外还可以把被访问的元素放到链表的底端，当内存容量满了的时候，这样一来每次顶端的元素就是remove的元素。 12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value; &#125; 当accessOrder为true时，此时会调用afterNodeAccess()方法： 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; 我们访问的节点Node会移动到最后，使之成为尾部节点，从而改变了数据在LinkedHashMap中的存储顺序。 LRU算法 LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。 具体实现如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class LRUCache &#123; private int cacheSize;//缓存大小 private Hashtable nodes;//缓存容器 private int currentSize;//当前缓存对象数量 private CacheNode first;//(实现双链表)链表头 private CacheNode last;//(实现双链表)链表尾 class CacheNode &#123; CacheNode prev;//前一节点 CacheNode next;//后一节点 Object value;//值 Object key;//键 CacheNode() &#123; &#125; &#125; public LRUCache(int i) &#123; currentSize = 0; cacheSize = i; nodes = new Hashtable(i);//缓存容器 &#125; /** * 获取缓存中对象 * * @param key * @return */ public Object get(Object key) &#123; CacheNode node = (CacheNode) nodes.get(key); if (node != null) &#123; moveToHead(node); return node.value; &#125; else &#123; return null; &#125; &#125; /** * 添加缓存 * * @param key * @param value */ public void put(Object key, Object value) &#123; CacheNode node = (CacheNode) nodes.get(key); if (node == null) &#123; //缓存容器是否已经超过大小. if (currentSize &gt;= cacheSize) &#123; if (last != null)//将最少使用的删除 nodes.remove(last.key); removeLast(); &#125; else &#123; currentSize++; &#125; node = new CacheNode(); &#125; node.value = value; node.key = key; //将最新使用的节点放到链表头，表示最新使用的. moveToHead(node); nodes.put(key, node); &#125; /** * 将缓存删除 * * @param key * @return */ public Object remove(Object key) &#123; CacheNode node = (CacheNode) nodes.get(key); if (node != null) &#123; if (node.prev != null) &#123; node.prev.next = node.next; &#125; if (node.next != null) &#123; node.next.prev = node.prev; &#125; if (last == node) last = node.prev; if (first == node) first = node.next; &#125; return node; &#125; public void clear() &#123; first = null; last = null; &#125; /** * 删除链表尾部节点 * 表示 删除最少使用的缓存对象 */ private void removeLast() &#123; //链表尾不为空,则将链表尾指向null. 删除连表尾（删除最少使用的缓存对象） if (last != null) &#123; if (last.prev != null) last.prev.next = null; else first = null; last = last.prev; &#125; &#125; /** * 移动到链表头，表示这个节点是最新使用过的 * * @param node */ private void moveToHead(CacheNode node) &#123; if (node == first) return; if (node.prev != null) node.prev.next = node.next; if (node.next != null) node.next.prev = node.prev; if (last == node) last = node.prev; if (first != null) &#123; node.next = first; first.prev = node; &#125; first = node; node.prev = null; if (last == null) last = first; &#125;&#125; 以上便是双链表的LRU实现，将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"https://lzxhh2017.github.io/tags/LinkedHashMap/"},{"name":"LRU算法","slug":"LRU算法","permalink":"https://lzxhh2017.github.io/tags/LRU算法/"}]},{"title":"Java中几种文件拷贝方式","date":"2019-03-07T11:56:42.000Z","path":"2019/03/07/Java中几种文件拷贝方式/","text":"前言 1、利用java.io.类库，使用FileInputStream读取文件，使用FileOutputStream写入文件； 2、利用java.nio类库提供的transferTo或transferFrom方式实现； 3、直接调用jdk1.7版本中的java.nio.file.Files.copy()实现。 利用java.io.类库，使用FileInputStream读取文件，使用FileOutputStream写入文件，代码如下所示： 12345678910111213public static void copyFileByStream(File source, File target) &#123; try &#123; InputStream is = new FileInputStream(source); OutputStream os = new FileOutputStream(target); byte[] buffer = new byte[1024]; int length; while ((length = is.read(buffer)) &gt; 0) &#123; os.write(buffer, 0, length); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 利用java.nio类库提供的transferTo或transferFrom方式实现，代码如下所示： 12345678910111213141516public static void copyFileByChannel(File source, File target) &#123; try &#123; FileChannel inputChannel = new FileInputStream(source).getChannel(); FileChannel outputChannel = new FileOutputStream(target).getChannel(); //transferTo实现 long count = inputChannel.size(); while (count &gt; 0) &#123; long transferred = inputChannel.transferTo(inputChannel.position(), count, outputChannel); count -= transferred; &#125; //transferFrom实现 //outputChannel.transferFrom(inputChannel, 0, inputChannel.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 直接调用jdk1.7版本中的java.nio.file.Files.copy()实现，代码如下所示： 12345678public static void copyFileByFiles(File source, File target) &#123; try &#123; Files.copy(source.toPath(), target.toPath()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://lzxhh2017.github.io/tags/IO/"}]},{"title":"如何手写HTTP协议？","date":"2019-03-06T05:50:04.000Z","path":"2019/03/06/如何手写HTTP协议？/","text":"前言 一个典型HTTP1.1的请求协议报文结构，大体上可以分为三块，即请求行、头部、消息主体。 因为HTTP协议是在接收到数据之后才会用到的，所以我们只需要修改NioServer中的Handler就可以了，在修改后的HttpHandler中首先获取到请求报文并打印出报文的头部（包含首行）、请求的方法类型、Url和Http版本，最后将接收到的请求报文信息封装到响应报文的主体中返回给客户端。这里的HttpHandler使用了单独的线程来执行，而且把SelectionKey中操作类型的选择也放在了HttpHandler中，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.company.http;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.util.Iterator;public class HttpServer &#123; public static void main(String[] args) throws IOException &#123; //创建ServerSocketChannel ServerSocketChannel ssc = ServerSocketChannel.open(); //监听8080端口 ssc.bind(new InetSocketAddress(8080)); //设置为非阻塞模式 ssc.configureBlocking(false); //为ssc注册选择器 Selector selector = Selector.open(); ssc.register(selector, SelectionKey.OP_ACCEPT); //创建处理器 while (true) &#123; //等待请求，每次等待阻塞3s，超过3s后县城继续向下运行，如果传入0或者不传参数将一直阻塞 if (selector.select(3000) == 0) &#123; continue; &#125; //获取待处理的SelectionKey Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); //启动新线程处理SelectionKey new Thread(new HttpHandler(key)).run(); //处理完成后，从待处理的SelectionKey迭代器中移除当前所使用的key keyIterator.remove(); &#125; &#125; &#125; private static class HttpHandler implements Runnable &#123; private int bufferSize = 1024;// 缓冲器容量 private String localCharset = \"UTF-8\";// 编码格式 private SelectionKey key; public HttpHandler(SelectionKey key) &#123; this.key = key; &#125; public void handleAccept() throws IOException &#123; SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept(); clientChannel.configureBlocking(false); clientChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)); &#125; public void handleRead() throws IOException &#123; //获取channel SocketChannel sc = (SocketChannel) key.channel(); //获取buffer并重置 ByteBuffer buffer = (ByteBuffer) key.attachment(); buffer.clear(); //没有读到内容则关闭 if (sc.read(buffer) == -1) &#123; sc.close(); &#125; else &#123; //接收请求数据 buffer.flip(); String receivedString = Charset.forName(localCharset).newDecoder().decode(buffer).toString(); //控制台打印请求报文头 String[] requestMessage = receivedString.split(\"\\r\\n\"); for (String s : requestMessage) &#123; System.out.println(s); //遇到空行说明报文头已经打印完 if (s.isEmpty()) &#123; break; &#125; &#125; //控制台打印首行信息 String[] firstLine = requestMessage[0].split(\" \"); System.out.println(); System.out.println(\"Method:\\t\" + firstLine[0]); System.out.println(\"url:\\t\" + firstLine[1]); System.out.println(\"http version:\\t\" + firstLine[2]); System.out.println(); //返回客户端 StringBuffer sendString = new StringBuffer(); //响应报文首行，200表示处理成功 sendString.append(\"HTTP/1.1 200 OK\\r\\n\"); sendString.append(\"Content-Type:text/html;charset=\" + localCharset + \"\\r\\n\"); //报文头结束后加一个空行 sendString.append(\"\\r\\n\"); sendString.append(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;显示报文&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"); sendString.append(\"接收到请求报文是：\"); for (String s : requestMessage) &#123; sendString.append(s + \"&lt;br/&gt;\"); &#125; sendString.append(\"&lt;/body&gt;&lt;/html&gt;\"); buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset)); sc.write(buffer); sc.close(); &#125; &#125; @Override public void run() &#123; try &#123; //接收到连接请求时 if (key.isAcceptable()) &#123; handleAccept(); &#125; //读数据 if (key.isReadable()) &#123; handleRead(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;&#125; 浏览器访问http://localhost:8080，Java控制台打印如下所示： 浏览器中显示结果如下所示：","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://lzxhh2017.github.io/tags/HTTP/"}]},{"title":"Java设计模式之建造者模式","date":"2019-03-05T05:41:36.000Z","path":"2019/03/05/Java设计模式之建造者模式/","text":"前言 在平时的日常生活中，我们往往会去餐馆吃饭，而同一道菜，每次我们去吃都会有不同的味道。就拿中国最有名的菜系“鱼香肉丝”来说，可以吃出千万种味道，不同的餐馆，不同的厨师，不同的时间，做出来的味道可能千差万别。但是我们所熟悉的肯德基、麦当劳、华莱士这些店铺的汉堡、炸鸡，为什么味道相差不大，基本上一样的呢？原因是因为这些门店都有非常规范的工作流程，所以做出来的食品味道也基本上是一样的。 什么是建造者模式？将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。 建造者模式通常包含以下四种角色： Builder：为创建一个产品对象的各个部件指定抽象接口。 ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 Product：要创建的复杂对象。 建造者模式UML结构图 建造者模式实例 下面以建造游戏人物为例，游戏人物需要构建头部、身体和四肢。 Product产品类 1234567891011121314151617181920212223242526272829public class Person &#123; private String head;//头部 private String body;//身体 private String limbs;//四肢 public String getHead() &#123; return head; &#125; public void setHead(String head) &#123; this.head = head; &#125; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getLimbs() &#123; return limbs; &#125; public void setLimbs(String limbs) &#123; this.limbs = limbs; &#125;&#125; 抽象接口Builder类 12345678910public interface Builder &#123; public void buildHead(); public void buildBody(); public void buildLimbs(); public Person buildPerson();&#125; ConcreteBuilder类 12345678910111213141516171819202122232425262728public class PersonBuilder implements Builder &#123; private Person person; public PersonBuilder() &#123; person = new Person(); &#125; @Override public void buildHead() &#123; person.setHead(\"这是头部\"); &#125; @Override public void buildBody() &#123; person.setBody(\"这是身体\"); &#125; @Override public void buildLimbs() &#123; person.setLimbs(\"这是四肢\"); &#125; @Override public Person buildPerson() &#123; return person; &#125;&#125; 指挥者Director类 123456789public class Director &#123; public Person constructPerson(Builder builder) &#123; builder.buildHead(); builder.buildBody(); builder.buildLimbs(); return builder.buildPerson(); &#125;&#125; 客户端实现类BuilderTest 1234567891011public class BuilderTest &#123; public static void main(String[] args) &#123; Director director = new Director(); Person person = director.constructPerson(new PersonBuilder()); System.out.println(\"头部：\" + person.getHead()); System.out.println(\"身体：\" + person.getBody()); System.out.println(\"四肢：\" + person.getLimbs()); &#125;&#125; 测试结果如下所示： 建造者模式的应用场景（StringBuilder）StringBuilder中使用了建造者模式。 StringBuilder把构建者的角色交给了其的父类AbstractStringBuilder。 代码如下所示：StringBuilder（指导者）12345public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123;&#125; AbstractStringBuilder（抽象类） Appendable（接口）12345public interface Appendable &#123; Appendable append(CharSequence csq) throws IOException; Appendable append(CharSequence csq, int start, int end) throws IOException; Appendable append(char c) throws IOException;&#125; 总结当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用建造者模式。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"建造者模式","slug":"建造者模式","permalink":"https://lzxhh2017.github.io/tags/建造者模式/"}]},{"title":"Java设计模式之代理模式","date":"2019-03-04T12:02:40.000Z","path":"2019/03/04/Java设计模式之代理模式/","text":"前言 在我们的现在生活中，我们都会面临买房子的状况，通常我们都会找房地产中介帮忙，在这里房地产中介就起到了一个代理的作用。代理对象可以在客户端和目标对象间起到中介作用，而且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。代理模式是一种很好实现客户对象与代理对象分离的策略。 代理模式的UML图 从UML图中可以看出，Subject类中定义了RealSubject和ProxySubject的共用接口，保证客户端使用的透明性。 代理模式的实现静态代理Subject接口的实现 123public interface BuyHouseService &#123; public void buyHouse();&#125; 真实实体RealSubject类 12345678910111213141516171819202122232425public class Customer implements BuyHouseService &#123; private String name; private Double money; @Override public void buyHouse() &#123; System.out.println(name + \"买房子首付付了：\" + money + \"元\"); &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 代理Proxy类 12345678910111213public class HouseProxy implements BuyHouseService &#123; private Customer customer; public HouseProxy(Customer customer) &#123; this.customer = customer; &#125; @Override public void buyHouse() &#123; customer.buyHouse(); &#125;&#125; 客户端测试类 1234567public static void main(String[] args)&#123; Customer customer = new Customer(); customer.setName(\"张三\"); customer.setMoney(300000D); HouseProxy houseProxy = new HouseProxy(customer); houseProxy.buyHouse(); &#125; 输出结果如下： 上述代码就是静态代理模式简单实现，代理类实现了一个Subject接口的对象，任何实现该接口的对象，都可以通过代理类进行代理，增加了通用性。但是当需要大量代理类时，系统结构会变得比较臃肿。而且当接口需要修改方法时，不仅其所有实现类需要修改代码，代理类也要修改，程序就会变得复杂和难以维护。 动态代理 动态代理是根据代理的对象，动态创建代理类。这样就可以避免静态代理中代理类接口过多的问题。动态代理是实现方式，是通过反射来实现的，借助Java自带的java.lang.reflect.Proxy，通过固定的规则生成。 定义一个动态代理类，实现InvocationHandler接口，具体如下所示： 1234567891011121314public class DynamicProxy implements InvocationHandler &#123; Object object;//被代理类的实例 public DynamicProxy(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = method.invoke(object, args); return result; &#125;&#125; 客户端实现类： 12345678public static void main(String[] args) &#123; Customer customer = new Customer(); customer.setName(\"张三\"); customer.setMoney(300000D); DynamicProxy proxy = new DynamicProxy(customer); BuyHouseService buyHouseService = (BuyHouseService) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), customer.getClass().getInterfaces(), proxy); buyHouseService.buyHouse(); &#125; 输出结果如下所示： 总结以上就是java代理模式的实现，使用Java动态代理机制大大减少了代码量，增强了系统扩展性。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://lzxhh2017.github.io/tags/代理模式/"}]},{"title":"Java队列","date":"2019-03-02T11:47:47.000Z","path":"2019/03/02/Java队列/","text":"前言 在我们现实生活中，大家经常都会遇到排队的事情。比如说我们排队取火车票，排队取快餐，排队办理银行业务等诸多这样的事情，这些事情都遵从一个原则，谁站在前面，谁就能先拿到东西，拿到东西后就可以离开，而后面的人要获取东西，则必须从最后一个进行排队。 什么是Queue？队列是先进先出（FIFO）数据结构，尾部添加、头部删除（先进队列的元素先出队列），在Queue后面添加元素的过程称为Enqueue，从队列前面删除元素的过程称为Dequeue。跟我们生活中的排队类似。如下图所示： 首先，Queue继承自Collection，它也是集合家族的一员。Queue接口主要提供了以下方法： 123456789101112//将指定的元素插入此队列，当队列已满，会抛出IllegalStateException异常boolean add(E e);//将指定的元素插入此队列，容量限制队列时，通常使用此方法，当队列已满，则返回falseboolean offer(E e);//检索并删除此队列的头部，当队列为空时，会抛出NoSuchElementException异常E remove();//检索并删除此队列的头部，当队列为空时，返回nullE poll();//检索但不删除此队列的头部，当队列为空时，会抛出NoSuchElementException异常E element();//检索但不删除此队列的头部，当队列为空时，返回nullE peek(); 抛出异常 返回值 插入 add(e) offer(e) 删除 remove() poll() 检索 element() peek() 测试用例： 123456789101112131415161718public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList(); queue.add(\"元素A\"); queue.add(\"元素B\"); queue.add(\"元素C\"); System.out.println(queue); Queue&lt;String&gt; queue1 = new LinkedList(); try &#123; queue1.element(); &#125;catch (NoSuchElementException elementException)&#123; System.out.println(\"抛出NoSuchElementException异常\"); &#125; try &#123; queue1.remove(); &#125;catch (NoSuchElementException elementException)&#123; System.out.println(\"抛出NoSuchElementException异常\"); &#125; &#125; 输出结果如下： 从上图中可以看到，queue是一个先进先出的队列，当队列为空时，会抛出异常。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://lzxhh2017.github.io/tags/Queue/"}]},{"title":"Java中Random类和ThreadLocalRandom类","date":"2019-03-01T02:41:29.000Z","path":"2019/03/01/Java中Random类和ThreadLocalRandom类/","text":"前言 在Java中只要一提到随机数，很多人就会想到Random类，如果有生成随机数的需求的时候，大多数时候我们都会选择使用Random来进行随机数生成。那么我们经常使用的随机数生成器Random类的原理是什么？及其局限性是什么？ Random类的定义 Random类位于java.util包中，主要用于生成伪随机数；Random类将种子数作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关；创建Random实例时，若没有指定种子数，则会以当前时间作为种子数，来计算生成伪随机数；拥有相同种子的Random实例，在相同次数下，生成的伪随机数完全相同。 1234567public static void main(String[] args) &#123; // write your code here Random random1 = new Random(10); Random random2 = new Random(10); System.out.println(random1.nextInt()); System.out.println(random2.nextInt()); &#125; 输出结果如下所示： Random原理我们先来看一下Random()的构造方法： 12345678910111213141516171819202122public Random() &#123; this(seedUniquifier() ^ System.nanoTime()); &#125;public Random(long seed) &#123; if (getClass() == Random.class) this.seed = new AtomicLong(initialScramble(seed)); else &#123; // subclass might have overriden setSeed this.seed = new AtomicLong(); setSeed(seed); &#125; &#125;private static long seedUniquifier() &#123; // L'Ecuyer, \"Tables of Linear Congruential Generators of // Different Sizes and Good Lattice Structure\", 1999 for (;;) &#123; long current = seedUniquifier.get(); long next = current * 181783497276652981L; if (seedUniquifier.compareAndSet(current, next)) return next; &#125; &#125; 从上述源码中可以看出，在无参的构造方法，里面根据当前时间帮我们自动产生了一个种子，并通过CAS自旋方式保证，每次获取的种子不一样，从而保证每次new Random()获取的随机序列不一致。 当传入一个种子（有参数），来生成随机数，通过上面的例子发现，种子一样产生的随机数序列一样，如果每次使用想产生不一样的序列，那就只能每次传入一个不一样的种子。接着我们来看一下nextInt()函数： nextInt()1234567891011121314public int nextInt() &#123; return next(32); &#125;protected int next(int bits) &#123; long oldseed, nextseed; //这里用到了concurrent 包中的原子Long AtomicLong seed = this.seed; do &#123; oldseed = seed.get(); nextseed = (oldseed * multiplier + addend) &amp; mask; &#125; while (!seed.compareAndSet(oldseed, nextseed)); //这里就是经典的CAS的Java实现 return (int)(nextseed &gt;&gt;&gt; (48 - bits)); &#125; 从上述代码中可以看出nextInt()里面直接调用的是next()方法，传入的32，这里的32指的是Int的位数。这里会根据seed当前的值，通过一定的规则(伪随机)算出下一个seed，然后进行cas，如果cas失败继续循环上面的操作。最后根据我们需要的bit位数来进行返回。如果种子确定后，每次产生的数，都是采用固定的算法进行产生的，所以只要种子确定后，每次产生的序列就是固定的。 nextInt(int bound)12345678910111213141516public int nextInt(int bound) &#123; if (bound &lt;= 0) throw new IllegalArgumentException(BadBound); int r = next(31); int m = bound - 1; if ((bound &amp; m) == 0) // i.e., bound is a power of 2 r = (int)((bound * (long)r) &gt;&gt; 31); else &#123; for (int u = r; u - (r = u % bound) + m &lt; 0; u = next(31)) ; &#125; return r; &#125; 具体步骤如下： 1、首先获取31位的随机数，注意这里是31位，和上面32位不同，因为在nextInt()方法中可以获取到负数的随机数，而nextInt(int bound)规定只能获取到[0,bound)之前的随机数，也就是必须是正数，而int的第一位是符号位所以只获取了31位。 2、然后进行取bound操作。 3、如果bound是2的幂，那么直接将第一步获取的数据乘以bound然后右移31位，解释一下:如果bound是4那么,如果乘以4其实就是左移2位，那么其实就是变成了33位，那么再右移31位的话，就又会变成2位，那么2位的int的大小范围其实就是[0,4)了。 4、如果不是2的幂，通过取余的操作进行处理。 Random性能问题从 Random 源码中我们发现，每次获取随机数的时候都是使用CAS的方式进行更新种子的值。这样在高并发的环境中会存在大量的CAS重试，导致性能下降。 ThreadLocalRandom ThreadLocalRandom类是JDK7在JUC包下新增的随机数生成器，它解决了Random类在多线程下多个线程竞争内部唯一的原子性种子变量而导致大量线程自旋重试的不足。 12345678public static void main(String[] args) &#123; //获取一个随机数生成器 ThreadLocalRandom random = ThreadLocalRandom.current(); //输出10个在0-10（包含0，不包含10，左闭右开）之间的随机数 for (int i = 0; i &lt; 10; ++i) &#123; System.out.println(random.nextInt(10)); &#125; &#125; 从上述代码可以看出调用ThreadLocalRandom.current()来获取当前线程的随机数生成器。接着来看下current()方法： 1234567891011121314public static ThreadLocalRandom current() &#123; //判断是否初始化 if (UNSAFE.getInt(Thread.currentThread(), PROBE) == 0) localInit();//进行初始化操作 return instance; &#125;static final void localInit() &#123; int p = probeGenerator.addAndGet(PROBE_INCREMENT); int probe = (p == 0) ? 1 : p; // skip 0 long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT)); Thread t = Thread.currentThread(); UNSAFE.putLong(t, SEED, seed); UNSAFE.putInt(t, PROBE, probe); &#125; 从上述代码可以看见如果没有初始化会对其进行初始化，而这里我们的seed不再是一个全局变量，在我们的Thread中有三个变量: 1234567891011/** The current seed for a ThreadLocalRandom */ @sun.misc.Contended(\"tlr\") long threadLocalRandomSeed;//用来控制随机数的种子 /** Probe hash value; nonzero if threadLocalRandomSeed initialized */ @sun.misc.Contended(\"tlr\") int threadLocalRandomProbe;//用来控制初始化 /** Secondary seed isolated from public ThreadLocalRandom sequence */ @sun.misc.Contended(\"tlr\") int threadLocalRandomSecondarySeed;//二级种子 可以看见所有的变量都加了@sun.misc.Contended这个注解，这个是用来处理伪共享的问题。 nextInt()方法123456789protected int next(int bits) &#123; return (int)(mix64(nextSeed()) &gt;&gt;&gt; (64 - bits)); &#125;final long nextSeed() &#123; Thread t; long r; // read and update per-thread seed UNSAFE.putLong(t = Thread.currentThread(), SEED, r = UNSAFE.getLong(t, SEED) + GAMMA); return r; &#125; 如上代码首先使用 r = UNSAFE.getLong(t, SEED)获取当前线程中threadLocalRandomSeed变量的值，然后在种子的基础上累加GAMMA值作为新种子，然后使用UNSAFE的putLong方法把新种子放入当前线程的threadLocalRandomSeed变量。 测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class RandomTest &#123; private static Random random = new Random(); private static final int N = 100000; //Random from java.util.concurrent. private static class TLRandom implements Runnable &#123; @Override public void run() &#123; int x = 0; for (int i = 0; i &lt; N; i++) &#123; x += ThreadLocalRandom.current().nextInt(); &#125; &#125; &#125; //Random from java.util private static class URandom implements Runnable &#123; @Override public void run() &#123; int x = 0; for (int i = 0; i &lt; N; i++) &#123; x += random.nextInt(); &#125; &#125; &#125; public static void main(String[] args) &#123; System.out.println(\"threadNum,Random,ThreadLocalRandom\"); for (int threadNum = 50; threadNum &lt;= 2000; threadNum += 50) &#123; ExecutorService poolR = Executors.newFixedThreadPool(threadNum); long RStartTime = System.currentTimeMillis(); for (int i = 0; i &lt; threadNum; i++) &#123; poolR.execute(new URandom()); &#125; try &#123; poolR.shutdown(); poolR.awaitTermination(100, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String str = \"\" + threadNum + \",\" + (System.currentTimeMillis() - RStartTime) + \",\"; ExecutorService poolTLR = Executors.newFixedThreadPool(threadNum); long TLRStartTime = System.currentTimeMillis(); for (int i = 0; i &lt; threadNum; i++) &#123; poolTLR.execute(new TLRandom()); &#125; try &#123; poolTLR.shutdown(); poolTLR.awaitTermination(100, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(str + (System.currentTimeMillis() - TLRStartTime)); &#125; &#125;&#125; 输出结果如下所示： 总结ThreadLocalRandom使用ThreadLocal的原理，让每个线程内持有一个本地的种子变量，该种子变量只有在使用随机数时候才会被初始化，多线程下计算新种子时候是根据自己线程内维护的种子变量进行更新，从而避免了竞争。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"Random","slug":"Random","permalink":"https://lzxhh2017.github.io/tags/Random/"},{"name":"ThreadLocalRandom","slug":"ThreadLocalRandom","permalink":"https://lzxhh2017.github.io/tags/ThreadLocalRandom/"}]},{"title":"设计模式优化if-else语句","date":"2019-02-27T11:27:45.000Z","path":"2019/02/27/设计模式优化if-else语句/","text":"前言 在平时项目中我们处理业务逻辑层通常会使用if-else来进行判断，在代码中大量的使用if-else，会显得代码十分冗长、臃肿，因为分支过多，阅读起来比较困难。如果这时候客户那边变更需求，需要改动if-else语句，这样不但违背了开放关闭原则，而且一不小心也会因为改动原有的代码而出错。那么应该如何优化呢？ 场景：提供以下几种方式支持地铁过闸：支付宝、微信、地铁卡 当使用if-else的方式来进行实现时，如下所示： 12345678910111213141516171819public static Double selectPayment(Double money, String type) &#123; if (type == \"Alipay\") &#123; System.out.println(\"支付宝扫码过闸！\"); return money * 0.85; &#125; else if (type == \"WechatPay\") &#123; System.out.println(\"微信扫码过闸！\"); return money * 0.8; &#125; else &#123; System.out.println(\"地铁卡过闸！\"); return money * 0.6; &#125; &#125; public static void main(String[] args) &#123; // write your code here System.out.println(Payment.selectPayment(10.00,\"Alipay\")); System.out.println(Payment.selectPayment(10.00,\"WechatPay\")); System.out.println(Payment.selectPayment(10.00,\"Card\")); &#125; 测试结果如下： 这样来实现简洁明了，业务逻辑关系一目了然。但是如果需求变更，客户提出需要使用刷银联卡也可以通过闸道，如果我们使用的是if-else实现，就必须要去更改逻辑代码，再加上一层逻辑判断，这样就不符合所谓的开闭原则，耦合性大。这时候我们就可以使用策略模式+工厂模式来进行实现。 过闸方式策略接口123public interface Strategy &#123; public Double selectPayment(Double money, String type);&#125; 支付宝过闸实现类123456public class Alipay implements Strategy &#123; @Override public Double selectPayment(Double money, String type) &#123; return money * 0.85; &#125;&#125; 微信过闸实现类123456public class WechatPay implements Strategy &#123; @Override public Double selectPayment(Double money, String type) &#123; return money * 0.8; &#125;&#125; 地铁卡过闸实现类123456public class Card implements Strategy &#123; @Override public Double selectPayment(Double money, String type) &#123; return money * 0.6; &#125;&#125; 过闸枚举类123456789101112131415161718public enum TypeEnum &#123; ALIPAY(\"Alipay\"), WECHATPAY(\"WechatPay\"), CARD(\"Card\"); private String type; private TypeEnum(String type) &#123; this.type = type; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125;&#125; 工厂类1234567891011121314151617181920212223public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private StrategyFactory() &#123; //构造方法 &#125; public static StrategyFactory getInstance() &#123; return factory; &#125; private static Map map = new HashMap(); //将对应的过闸方式放入map中 static &#123; map.put(\"Alipay\", new Alipay()); map.put(\"WechatPay\", new WechatPay()); map.put(\"Card\", new Card()); &#125; public Strategy getStrategy(String type) &#123; return (Strategy) map.get(type); &#125;&#125; 策略上下文类12345678910111213141516public class StrategyContext &#123; private Strategy strategy; public Double selectPayment(Double money, String type) &#123; strategy = StrategyFactory.getInstance().getStrategy(type); return strategy.selectPayment(money,type); &#125; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125;&#125; 测试类12345678910111213public class Test &#123; public static void main(String[] args) &#123; StrategyContext strategyContext = new StrategyContext(); System.out.println(\"支付宝扫码过闸！\"); System.out.println(strategyContext.selectPayment(10.00,\"Alipay\")); System.out.println(\"微信扫码过闸！\"); System.out.println(strategyContext.selectPayment(10.00,\"WechatPay\")); System.out.println(\"地铁卡过闸！\"); System.out.println(strategyContext.selectPayment(10.00,\"Card\")); &#125;&#125; 输出结果如下所示： 将代码重构后可以发现，如果需要新增一种过闸方式，比如银联卡刷卡过闸，只需新增实现类和枚举类，不需要去修改业务逻辑，增强了扩展性，完成了解耦合，符合开闭原则，提高了代码的可维护性。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"if-else","slug":"if-else","permalink":"https://lzxhh2017.github.io/tags/if-else/"}]},{"title":"HTTPS原理详解","date":"2019-02-26T01:08:20.000Z","path":"2019/02/26/HTTPS原理详解/","text":"前言 HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。 什么是HTTP？HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。 什么是HTTPS?HTTPS 称为安全的超文本传输协议，在 HTTP 与 TCP 之间增加了一层安全链路 (SSL/TLS)。(SSL 是 TLS 的前身，在 IETF 将 SSL 标准化后就改名叫 TLS，SSL 的最高版本为 3.0，之后版本为 TLS1.0，TLS1.1，TLS1.2…..)。 为什么要用HTTPS？下面来讲个故事，想必我们在学校里面都传过纸条，比如：小明给小花写了一个纸条：”小花，我喜欢你，你喜欢我吗？“；然后小明让小王传给小花，小王如果偷窥纸条的内容，看到了写给小花的内容，偏偏小王又喜欢小花，就不想把纸条传给小花，于是小王把纸条给截下，写了个纸条过去：”我是小王，你长得不好看，哈哈！“；本来是一件很美好的事情，然而被小王这样一捣乱，好事却变成了一桩坏事。 (1)、使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器;(2)、https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。(3)、https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 详解HTTP访问过程HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下所示： 可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”。 下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应，现象如下： 所以HTTP面临以下风险： 窃听风险。由于是明文传输，如果网络传输的某个节点被动了手脚，那么传输的内容就可被窃听。 篡改风险。由于是明文传输，在内容被窃听的同时，攻击者可以很容易的篡改传输内容，而HTTP本身没有校验报文完整性的能力。 冒充风险。无法验证通讯方的真实身份。 HTTP 向 HTTPS 演化的过程一、为了防止上述现象的发生，对传输的信息加密（即使黑客截获，也无法破解） 如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是： 不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高； 因每个客户端、服务器的安全级别不同，密钥极易泄露。 二、既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密 如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容。 三、非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势 如上图所示（1）第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器； （2）服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密； （3）后续两者之间信息的传输就可以使用对称加密的方式了。 遇到的问题：（1）客户端如何获得公钥； （2）如何确认服务器是真实的而不是黑客。 四、获取公钥与确认服务器身份 1、获取公钥（1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）； （2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）。 2、那有没有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到SSL 证书（用JDK自带的keytool工具生成或者申购）。 如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的主要内容有： （1）证书的发布机构CA （2）证书的有效期 （3）公钥 （4）证书所有者 （5）签名 3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验； （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发； （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的； （4）如果找到，那么浏览器就会从操作系统中取出颁发者CA的公钥，然后对服务器发来的证书里面的签名进行解密； （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比； （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充； （7）此时浏览器就可以读取证书中的公钥，用于后续加密了。 4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成。 所以相比HTTP，HTTPS传输更加安全 （1） 所有信息都是加密传播，黑客无法窃听。 （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 （3） 配备身份证书，防止身份被冒充。 总结综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://lzxhh2017.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://lzxhh2017.github.io/tags/HTTPS/"}]},{"title":"Java设计模式之单例模式","date":"2019-02-24T12:38:30.000Z","path":"2019/02/24/Java设计模式之单例模式/","text":"前言 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。 单例模式的几种实现方式 饿汉模式 懒汉模式 双重锁定 静态内部类 枚举单例 饿汉模式 在类加载时就完成了初始化，当单例很大的话，将会浪费很多的内存，所以类加载较慢，但获取对象的速度快。 1234567891011public class Singleton &#123; private static Singleton instance = new Singleton();//静态私有成员 private Singleton() &#123;//私有构造函数 &#125; public static Singleton getInstance() &#123; //静态，不用同步（类加载时已初始化，不会有多线程的问题） return instance; &#125;&#125; 懒汉模式 在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢。 1234567891011121314public class Singleton &#123; private static Singleton instance = null;//静态私有成员,没有初始化 private Singleton() &#123;//私有构造函数 &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 测试用例： 123456public static void main(String[] args) &#123; // write your code here Singleton s1 = new Singleton(); Singleton s2 = new Singleton(); System.out.println(s1 == s2); &#125; 输出结果如下所示： 单例模式因为Singleton类封装它的唯一实例，这样它可以严格的控制客户端怎样访问它以及何时访问它，也就是对唯一实例的受控访问。 多线程中的单例模式 在单线程下这种写法是可以的，但是在多线程下存在线程安全问题。当同一时间有两个或者两个以上线程进入getInstance()方法时，因为刚开始single都是null，几个线程都同时满足if(single==null)这个条件，就会同时new Singleton()这个对象。 测试用例： 1234567891011121314151617181920212223//SingletonThread类public class SingletonThread implements Runnable &#123; private Set&lt;Singleton&gt; set = new HashSet&lt;Singleton&gt;(); @Override public void run() &#123; Singleton single = Singleton.getInstance(); set.add(single); System.out.println(\"Set的大小为：\" + set.size() + \",\" + set); &#125;&#125;//main函数public static void main(String[] args) &#123; // write your code here SingletonThread t=new SingletonThread(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125; 输出结果如下所示： 那么应该如何优化呢？在高并发情况下，做到线程安全，保证多线程环境下同时访问也不会造成多个实例的出现，我们可以通过加上synchronized修饰符解决。 123456public synchronized static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 输出结果如下所示： 上述方式通过为 getInstence() 方法增加 synchronized 关键字，迫使每个线程在进入这个方法前，要先等候别的线程离开该方法，即不会有两个线程可以同时进入此方法执行 new Singleton()，从而保证了单例的有效。但它的致命缺陷是效率太低了，每个线程每次执行 getInstance() 方法获取类的实例时，都会进行同步。而事实上实例创建完成后，同步就变为不必要的开销了，这样做在高并发下必然会拖垮性能。我们继续优化。 双重锁定1234567891011121314151617181920private volatile static Singleton instance = null; private Singleton() &#123;//私有构造函数 System.out.println(\"生成一个Singleton实例\"); &#125; public synchronized static Singleton getInstance() &#123; // 第一重检查锁定 if (instance == null) &#123; // 同步锁定代码块 synchronized (Singleton.class) &#123; // 第二重检查锁定 if (instance == null) &#123; // 实例化对象 instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 当instance不为null的时候，直接返回实例；当instance为null时并且有多个线程调用getInstance方法时，通过第一重判断，然后通过synchronized机制，只有一个线程进入，另外的处于等待，如果不加第二重判断，第一个线程创建了实例，而后面的线程又可以创建新的实例，这样就没有达到单例的效果。从代码中可以看到在修饰instance变量的时候用到了volatile修饰符，那么起到了什么作用呢？ 禁止指令重排序。我们知道new Singleton()是一个非原子操作，编译器可能会重排序【构造函数可能在整个对象初始化完成前执行完毕，即赋值操作（只是在内存中开辟一片存储区域后直接返回内存的引用）在初始化对象前完成】。 保证可见性。线程1在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程2在主存中判断instance还是null，那么线程2又将在自己的工作线程中创建一个实例，这样就创建了多个实例。 静态内部类 静态内部类比双重检查锁定和在getInstance()方法上加同步都要好，实现了线程安全又避免了同步带来的性能影响。 1234567891011121314public class Singleton &#123; private Singleton() &#123;//私有构造函数 System.out.println(\"生成一个Singleton实例\"); &#125; public static final Singleton getInstance() &#123; return SingletonInner.INSTANCE; &#125; private static class SingletonInner &#123; private static final Singleton INSTANCE = new Singleton(); &#125;&#125; 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。即当SingleTon第一次被加载时，并不需要去加载SingletonInner，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE,第一次调用getInstance()方法会导致虚拟机加载SingletonInner类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。 枚举单例12345678910111213141516171819202122232425public class Instance &#123; public static Instance getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; public enum Singleton &#123; INSTANCE; private Instance instance; /** * JVM保证这个方法绝对只调用一次 */ Singleton() &#123; instance = new Instance(); &#125; public Instance getInstance() &#123; return instance; &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://lzxhh2017.github.io/tags/单例模式/"}]},{"title":"Java设计模式之策略模式","date":"2019-02-21T09:17:21.000Z","path":"2019/02/21/Java设计模式之策略模式/","text":"前言 设计模式作为一种经典的开发实践常常需要我们去深入的理解，而策略模式作为设计模式的一种，使用频率也是相对来说比较高的，Java中TreeSet集合就采用了经典的策略模式的思想。 简单工厂实现 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同的属性和功能的对象的抽象集合才是类。打一折和九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，应该是一个类。代码结构图如下： 现金收费抽象类： 1234public interface CashSuper&#123; public double acceptCash(double money); &#125; 正常收费子类： 1234567public class CashNormal implements CashSuper &#123; public double acceptCash(double money) &#123; return money; &#125; &#125; 打折收费子类： 1234567891011121314public class CashRebate implements CashSuper &#123; private double moneyRebate = 1; public CashRebate(double moneyRebate) &#123; this.moneyRebate = moneyRebate; &#125; public double acceptCash(double money) &#123; return money * moneyRebate; &#125; &#125; 返利收费子类： 123456789101112131415161718192021public class CashReturn implements CashSuper &#123; private double moneyCondition = 0; private double moneyReturn = 0; public CashReturn(double moneyCondition, double moneyReturn) &#123; this.moneyCondition = moneyCondition; this.moneyReturn = moneyReturn; &#125; public double acceptCash(double money) &#123; double result = money; if (money &gt;= moneyCondition) &#123; result = money - money / moneyCondition * moneyReturn; &#125; return result; &#125; &#125; 现金收费工厂类： 123456789101112131415161718192021public class CashFactory &#123; public static CashSuper createCash(String type) &#123; CashSuper cs = null; if (\"正常收费\".equals(type)) &#123; cs = new CashNormal(); &#125; else if (\"满300返100\".equals(type)) &#123; cs = new CashReturn(300, 100); &#125; else if (\"打8折\".equals(type)) &#123; cs = new CashRebate(0.8); &#125; return cs; &#125; &#125; 客户端程序： 12345678910111213141516171819202122public class Main &#123; private static double total = 0; public static void main(String[] args) &#123; consume(\"正常收费\", 1, 1000); consume(\"满300返100\", 1, 1000); consume(\"打8折\", 1, 1000); System.out.println(\"总计:\" + total); &#125; public static void consume(String type, int num, double price) &#123; CashSuper csuper = CashFactory.createCash(type); double totalPrices = 0; totalPrices = csuper.acceptCash(num * price); total += totalPrices; System.out.println(\"单价:\" + price + \" 数量:\" + num + \"合计:\" + totalPrices); &#125; &#125; 由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度的，每次维护或扩展收费方式都要改动这个工厂，以致代码需要重新编译部署，这是非常糟糕的处理方式，所以用它不是最好的办法。 策略模式 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。结构图如下所示： Strategy类，定义所有支持的算法的公共接口 1234public interface Strategy &#123; public void algorithmInterface(); &#125; ConcreteStrategy封装了具体的算法或行为，继承于Strategy 123456789101112131415161718192021public class ConcreteStrategyA implements Strategy &#123; public void algorithmInterface() &#123; System.out.println(\"算法A实现\"); &#125; &#125; public class ConcreteStrategyB implements Strategy &#123; public void algorithmInterface() &#123; System.out.println(\"算法A实现\"); &#125; &#125; public class ConcreteStrategyC implements Strategy &#123; public void algorithmInterface() &#123; System.out.println(\"算法C实现\"); &#125; &#125; Context用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用 1234567891011121314public class Context &#123; private Strategy strategy; public Context(Strategy strategy) //初始化时，传入具体的策略对象 &#123; this.strategy = strategy; &#125; public void contextInterface()//根据具体的策略对象，调用其算法的方法 &#123; strategy.algorithmInterface(); &#125; &#125; 客户端代码 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); &#125; &#125; 策略模式实现 正常收费CashNormal、打折收费CashRebate和返利收费CashReturn就是三个具体策略，也就是策略模式中说的具体算法。代码结构图如下： CashContext类 1234567891011121314public class CashContext &#123; CashSuper cashSuper; public CashContext(CashSuper cashSuper) &#123; this.cashSuper = cashSuper; &#125; public double acceptCash(double money) &#123; return cashSuper.acceptCash(money); &#125; &#125; 客户端代码 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; private static double total = 0; public static void main(String[] args) &#123; consume(\"正常收费\", 1, 1000); consume(\"满300返100\", 1, 1000); consume(\"打8折\", 1, 1000); System.out.println(\"总计:\" + total); &#125; public static void consume(String type, int num, double price) &#123; CashContext cashContext = null; if (\"正常收费\".equals(type)) &#123; cashContext = new CashContext(new CashNormal()); &#125; else if (\"满300返100\".equals(type)) &#123; cashContext = new CashContext(new CashReturn(300, 100)); &#125; else if (\"打8折\".equals(type)) &#123; cashContext = new CashContext(new CashRebate(0.8)); &#125; double totalPrices = cashContext.acceptCash(num * price); total += totalPrices; System.out.println(\"单价:\" + price + \" 数量:\" + num + \"合计:\" + totalPrices); &#125; &#125; 但是代码还是老样子，需要在客户端判断用哪一个算法。如何优化呢？ 策略与简单工厂结合 改造后的CashContext 123456789101112131415161718192021222324252627282930public class CashContext &#123; CashSuper cashSuper; public CashContext(CashSuper cashSuper) &#123; this.cashSuper = cashSuper; &#125; public CashContext(String type) &#123; if (\"正常收费\".equals(type)) &#123; cashSuper = new CashNormal(); &#125; else if (\"满300返100\".equals(type)) &#123; cashSuper = new CashReturn(300, 100); &#125; else if (\"打8折\".equals(type)) &#123; cashSuper = new CashRebate(0.8); &#125; &#125; public double acceptCash(double money) &#123; return cashSuper.acceptCash(money); &#125; &#125; 客户端代码 1234567891011121314151617181920212223public class Main &#123; private static double total = 0; public static void main(String[] args) &#123; consume(\"正常收费\", 1, 1000); consume(\"满300返100\", 1, 1000); consume(\"打8折\", 1, 1000); System.out.println(\"总计:\" + total); &#125; public static void consume(String type, int num, double price) &#123; CashContext cashContext = new CashContext(type); double totalPrices = cashContext.acceptCash(num * price); total += totalPrices; System.out.println(\"单价:\" + price + \" 数量:\" + num + \"合计:\" + totalPrices); &#125; &#125; 简单工厂模式需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂模式结合的用法，客户端就只需要认识一个类CashContext，耦合度更加降低。 策略模式解析 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法与使用算法之间的耦合。 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 当不同的行为堆砌于一个类中，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。 策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"策略模式","slug":"策略模式","permalink":"https://lzxhh2017.github.io/tags/策略模式/"}]},{"title":"Java设计模式之工厂模式","date":"2019-02-20T03:02:06.000Z","path":"2019/02/20/Java设计模式之工厂模式/","text":"前言 工厂模式实现了创建者和调用者的分离，实现了更好的解耦。 详细分类：（1）简单工厂模式（2）工厂方式模式（3）抽象工厂模式 下面将逐一介绍：简单工厂模式以计算器为例，结构图如下所示： 简单工厂类是这样写的： 123456789101112131415161718192021class OperationFactory&#123; public static Operation createOperate(String operate)&#123; Operation Oper = null; switch (operate) &#123; case \"+\": oper = new OperationAdd(); break; case \"-\": oper = new OperationSub(); break; case \"*\": oper = new OperationMul(); break; case \"/\": oper = new OperationDiv(); break; &#125; return oper; &#125;&#125; 客户端的应用 12345Operation oper;oper = OperationFactory.createOperate(\"+\");oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult(); 如果现在需要增加其他运算，比如求M的N次方，或者求M的N次方根，这样复杂性就增加了。因为如果加一个“求M的N次方”的功能，我们一定要给运算工厂类的方法添加“Case”的分支条件，这样即违背了开放-封闭原则（OCP(开闭原则, Open-Closed Principle)：一个软件的实体应当对扩展开放，对修改关闭）。 工厂方法模式实现结构图如下： 先构建一个工厂接口： 1234interface IFactory&#123; Operation CreateOperation();&#125; 然后加减乘除分别建立一个工厂去实现这个接口： 12345678910111213141516171819202122232425262728293031class AddFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationAdd(); &#125;&#125;class SubFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationSub(); &#125;&#125;class MulFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationMul(); &#125;&#125;class DivFactory : IFactory&#123; public Operation CreateOperation() &#123; return new OperationDiv(); &#125;&#125; 客户端的实现： 12345IFactory operFactory ＝ new AddFactory();Operation oper = operFactory.CreateOperation();oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult(); 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式结构图： 根据依赖倒转原则（ DIP(依赖倒转原则,Dependence Inversion Principle)：要针对接口编程，不要针对实现编程），我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂，当我们需要增加新的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。 这样整个工厂和产品体系其实都没有修改的变化，而只是扩展的变化，这就完全符合了开放－封闭原则的精神。 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移动到了客户端代码来运行。你想要加功能，本来是该工厂类的，而现在是修改客户端。 抽象工厂模式为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。 抽象工厂模式与工厂方法模式的区别 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。 在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。 明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。 1234567891011121314151617181920212223242526272829303132333435363738interface IProduct1 &#123; public void show(); &#125; interface IProduct2 &#123; public void show(); &#125; class Product1 implements IProduct1 &#123; public void show() &#123; System.out.println(\"这是1型产品\"); &#125; &#125; class Product2 implements IProduct2 &#123; public void show() &#123; System.out.println(\"这是2型产品\"); &#125; &#125; interface IFactory &#123; public IProduct1 createProduct1(); public IProduct2 createProduct2(); &#125; class Factory implements IFactory&#123; public IProduct1 createProduct1() &#123; return new Product1(); &#125; public IProduct2 createProduct2() &#123; return new Product2(); &#125; &#125; public class Client &#123; public static void main(String[] args)&#123; IFactory factory = new Factory(); factory.createProduct1().show(); factory.createProduct2().show(); &#125; &#125; 抽象工厂模式的优点：抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。 抽象工厂模式的缺点：产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。 适用场景：当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"设计模式","slug":"后端/设计模式","permalink":"https://lzxhh2017.github.io/categories/后端/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://lzxhh2017.github.io/tags/工厂模式/"}]},{"title":"Java关键字static","date":"2019-02-19T14:38:09.000Z","path":"2019/02/19/Java关键字static/","text":"前言 static是java中一重要的关键字，在一定环境下使用，可以提高程序的运行性能，优化程序的结构。（静态方法不能调用非静态的成员变量和成员方法。非静态方法可以调用静态的成员变量和成员方法。）因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。 其主要应用有以下几方面： 1.static修饰的成员变量，称为类变量/静态变量，以实现所有对象对该成员的共享。 2.static修饰的成员方法，称为类方法/静态方法，可直接通过类名调用，无需创建对象。 3.形成静态代码块，优化程序性能。 4.静态导包，一般将类的方法直接导入到当前类中，从而直接使用方法名即可调用类方法，更加方便。 5.修饰内部类，无需实例化外部类就可以调用内部类。 具体代码如下所示： 123456789101112131415161718192021222324252627public class Student &#123; String name; static int age; @Override public String toString() &#123; // TODO Auto-generated method stub return \"Name:\" + name + \", Age:\" + age; &#125; @SuppressWarnings(\"static-access\") public static void main(String[] args) &#123; Student s1 = new Student(); s1.name = \"张三\"; s1.age = 20; Student s2 = new Student(); s2.name = \"李四\"; s2.age = 10; System.out.println(s1); System.out.println(s2); &#125;&#125;/**输出结果：Name:张三, Age:10Name:李四, Age:10*/ 如上述代码所示，s1和s2两个对象分别存储在内存中堆区域的不同地址中，所以他们之间相互不会干扰。然而static关键字修饰了成员变量age，让其变成类的所属，而不是对象的所属，任何该类实例的对象都可以共享使用它。所以，输出的age均是最终赋给的10。如果去掉static，对象之间互不影响，输出如下： 123456789101112131415161718192021222324//Testpublic class Test extends Base &#123; static &#123; System.out.println(\"static静态块1\"); &#125; public Test() &#123; System.out.println(\"test构造器\"); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125;//Basepublic class Base &#123; static &#123; System.out.println(\"static静态块2\"); &#125; public Base() &#123; System.out.println(\"base构造器\"); &#125;&#125; 如上述代码，static代码块随类的加载一起加载。static修饰的变量方法比其他变量方法优先加载，且只加载一次。加载子类时，会首先加载父类。由此可以分析：在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。 12345678910111213141516171819//A.javapackage demo;public class A &#123; public static void outWord(Object o) &#123; System.out.println(o); &#125;&#125;//B.javapackage demo;import static demo.A.*;public class B &#123; public static void main(String[] args) &#123; outWord(\"Hello World!\");//A.outWord(\"Hello World!\");不用static的情況 &#125;&#125; 如上述代码，A.java中包含一个简单的静态方法，在B.java中我们用static关键字将A类导入，由此，便无需使用“类名.方法名”的方法去调用类方法了，直接可以采用”方法名”去调用类方法。 123456789101112131415161718192021222324252627282930313233public class C &#123; static &#123; System.out.println(\"C静态块\"); &#125; public C() &#123; System.out.println(\"C构造器\"); &#125; static class D &#123; static &#123; System.out.println(\"D静态块\"); &#125; public D() &#123; System.out.println(\"D构造器\"); &#125; &#125;&#125;//测试类import demo.C;public class Test&#123; public static void main(String[] args) &#123; new C.D(); &#125;&#125;/**输出结果：D静态块D构造器*/ 如上述代码，用static修饰内部类，外部类可以直接调用内部类，因为static修饰的的内部类是在加载外部类的同时加载的，所以，并不要实例化外部类就能直接调用静态内部类。例子中，在进入Test的main方法之前，加载Test类，然后执行new C.D()这里需要注意：因为D是静态的，所以这里并不需要加载外部类和实例化外部类，可以直接加载D并实例化。 此外，static另一个很重要的应用就是实现单例设计模式。单利模式的特点是该类只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象，于是只能把创建对象的方法声明为static，程序实例如下： 12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"static","slug":"static","permalink":"https://lzxhh2017.github.io/tags/static/"}]},{"title":"List去重之Set","date":"2019-02-17T14:17:49.000Z","path":"2019/02/17/List去重之Set/","text":"前言 我们都知道，List集合是允许重复的元素存在的。这里要阐明的List去重是通过将List集合转换成Set。Set是最简单的一种集合，不保存重复的元素，集合中的对象不按特定的方式排序，并且没有重复对象。 我们新建一个Test类，如下所示： 1234567891011121314151617181920public class Test &#123; @SuppressWarnings(&#123; \"unchecked\", \"rawtypes\" &#125;) public static void main(String[] args) &#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(1); System.out.println(list); //创建一个set集合 Set set = new HashSet(); //创建一个新的list集合 List newList = new ArrayList(); set.addAll(list); newList.addAll(set); System.out.println(newList); &#125;&#125; 输出结果为： 从上图可以看出，通过将List集合转化成Set集合，达到了去重的效果。 但是当list集合中存储的不是元素，而是对象类型的时候，我们还可以简单的把list集合转换成set集合吗？那么我们来验证一下。 我们先定义一个对象（User）类： 12345678910111213141516171819202122232425262728293031323334public class User &#123; private String name; private String sex; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public User(String name, String sex, Integer age) &#123; super(); this.name = name; this.sex = sex; this.age = age; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return \"&#123;name=\" + name + \",\" + \"sex=\" + sex + \",\" + \"age=\" + age + \"&#125;\"; &#125;&#125; 我们使用上面的set去重的方法去重： 1234567891011121314public class Test1 &#123; public static void main(String[] args) &#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"张三\", \"男\", 23)); list.add(new User(\"李四\", \"女\", 23)); list.add(new User(\"王五\", \"男\", 23)); list.add(new User(\"张三\", \"男\", 23)); System.out.println(list.toString()); Set&lt;User&gt; setList = new HashSet&lt;User&gt;(); setList.addAll(list); System.out.println(setList.toString()); &#125;&#125; 运行后输出的结果为： 从上图我们可以看出，出现两个张三，并没有达到去重的效果。 那么应该如何去重呢？我们都知道HashSet可以用来去重，那么是如何去重的呢？我们看源码可以看出HashSet的去重就是根据HashMap实现的，而HashMap的实现又完全依赖于hashcode和equals方法。 由此我们可以推断出，当list集合中存储的是对象时，我们必须在对象的实体类中重写equals()方法和hashCode()方法，如下面所示： 1234567891011121314@Override public int hashCode() &#123; // TODO Auto-generated method stub String str = name + sex + age; return str.hashCode(); &#125; @Override public boolean equals(Object obj) &#123; // TODO Auto-generated method stub User user = (User) obj; return name.equals(user.name) &amp;&amp; sex.equals(user.sex) &amp;&amp; age.equals(user.age); &#125; 在User类中重写这两个方法后，我们再去运行Test1这个类，我们可以发现去重成功了。如下图所示： 下面我们来看下equals()方法和hashCode()方法的具体实现： equals() 从源码中可以看出，两个对象相互比较时，首先会比较地址，如果是同一对象的引用，则判断为对象相等，结果返回true；如果地址不一样，则说明不是引用同一个对象，equals方法则会对两个字符串对象内的字符进行挨个比较，如果完全相等返回true，否则返回false。 hashCode() hashCode()是Object中的方法。由于hashCode方法定义在Object类中，所以每个对象都有一个默认的散列码，其值为对象的存储地址。 当equals方法被重新定义，hashCode方法也要跟着重新定义，以便用户可以将对象插入到散列表中。 Equals和hashCode的定义必须是一致的：如果a.equals(b)返回true，那么a.hashCode()就必须与b.hashCode()具有相同的值。","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Java","slug":"后端/Java","permalink":"https://lzxhh2017.github.io/categories/后端/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://lzxhh2017.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://lzxhh2017.github.io/tags/Set/"},{"name":"集合","slug":"集合","permalink":"https://lzxhh2017.github.io/tags/集合/"}]},{"title":"你想了解的前端知识都在这里","date":"2018-12-24T12:55:43.000Z","path":"2018/12/24/你想了解的前端知识都在这里/","text":"前言 这里介绍了HTML5、CSS3、JS、ES6、包管理工具、前端框架以及构建工具等前端网站。 核心 Core HTML5W3C http://www.w3school.com.cn/html5/W3C https://www.w3.org/html/ig/zh/wiki/HTML5菜鸟教程 http://www.runoob.com/html/html5-intro.htmlHTML5中文门户 http://www.html5cn.org/ CSS3W3C CSS教程 http://www.w3school.com.cn/css/index.aspW3C CSS3教程 http://www.w3school.com.cn/css3/index.asp菜鸟教程CSS教程 http://www.runoob.com/css/css-tutorial.html菜鸟教程CSS3教程 http://www.runoob.com/css3/css3-tutorial.htmlCSS参考手册 http://css.doyoe.com/ JSW3C http://www.w3school.com.cn/js/菜鸟教程 http://www.runoob.com/js/js-tutorial.html廖雪峰js教程 http://www.liaoxuefeng.comjs标准参考教程-阮一峰http://javascript.ruanyifeng.com/ jQueryW3C http://www.w3school.com.cn/jquery/菜鸟教程 http://www.runoob.com/jquery/jquery-tutorial.html极客学院 http://wiki.jikexueyuan.com/project/jquery-tutorial/廖雪峰 http://www.liaoxuefeng.com/wiki/参考手册 http://www.css88.com/jqapi-1.9/参考手册 http://www.runoob.com/manual/jquery/ ES6阮一峰ES6 http://es6.ruanyifeng.com/极客学院 http://wiki.jikexueyuan.com/project/es6/JavaScript 标准参考 阮一峰http://javascript.ruanyifeng.com/advanced/ecmascript6.html 插件parallel.js: 前后端通用的一个并行库zepto: 用于现代浏览器的兼容 jQuery 的库totoro: 稳定的跨浏览器测试工具TheaterJS: 一个用于模拟人输入状态的 JS 库stellar.js: 前端用于实现异步滚动效果的库，现已不再维护skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，看真相Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序regulex: 用于生成 正则表达式 的可视化流程图markdown-it: 新型 Markdown 解析器，快速，支持插件multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Docscreenfull.js: 全屏插件，支持各大浏览器lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用jquery.hotkeys: jQuery 插件，用于绑定热键breach_core: Javascript 编写的 Browser (浏览器)octocard: 用于生成 Github 信息卡片的库github-cards: 用于生成 Github 信息卡片的库money.js: 轻量级货币转换库，web 和 node 皆可用accounting.js: 轻量级的数字、货币转换库javascript-algorithms: Javascript 实现的各种算法集合lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升seajs: 前端模块加载器，解决模块化、依赖等问题jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库js.js: Javascript 实现的 javascript JITjquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大todomvc: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库localForage: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口EventEmitter: 浏览器版的 EventEmitterjquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据knockout: 前端 MVVM 框架，用于开发富前端应用mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品zoomooz: jQuery 插件，用来处理浏览器缩放fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 Reactbackbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果jquery-validation: jQuery 的一个插件，用于校验 Form 表单BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度qrcode-generator: 各种语言的二维码生成工具device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSSjquery-qrcode: jQuery 插件，用来生成二维码Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demolazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片progressbar.js: 简洁美观的进度条，扁平化pigshell: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务spectrum: Js实现的颜色选择器 (Colorpicker)jQuery.countdown: jQuery 倒计时插件summernote: WYSIWYG 富文本编辑器awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器trix: Basecamp 公司出品的富文本编辑器，简洁小巧sensor.js: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等hyhyhy: 用于创建 基于 HTML5 的 演示文稿swipebox: jQuery 插件，用于处理移动端的触摸事件FileAPI: 前端用户处理文件（拖放、多文件上传等）Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuerySwiper: 用于实现浏览器上的滑动切换效果，支持硬件加速matter-js: 2D 物理效果引擎，碰撞、弹跳等jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库c3: 基于 D3 的图表库echarts: 企业级图表库，百度开发parallax.js: 一个用于响应智能手机 orientation 的库jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器wysihtml: 富文本编辑器，适用于现代浏览器slip: 一个通过滑动或者拖拽来操控列表的库evil-icons: 一个矢量图库，提供 Ruby/Node 等支持PhotoSwipe: JS 的一个图片展示库focusable: 是页面上一个元素高亮的库，有图有真相firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefoxjquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5mobile-angular-ui: 基于angularjs和bootstarp的web app开发框架interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库rebound-js: 实现部分物理效果，Facebook 出品basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品accessible-html5-video-player: Paypal 出品的 Video 播放器loading: 几种 Loading 效果，基于 SVGflippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的move.js: 基于 CSS3 的前端动画框架scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 DemoModernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库foundation: 另一款前端模版框架，类似于 BootstrapFlat-UI: Bootstrap 的一款主题，简洁美观iCheck: 一款漂亮的 Checkbox 插件Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kbslick: 功能异常强大的一个图片滑动切换效果库SocialButtons: 漂亮的社交按钮sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库web-animations-js: Javascript 实现的 Web Animation APIvivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画plyr: 轻量, 小巧, 美观的 HTML5 视频播放器timesheet.js: 基于 HTML5 &amp; CSS3 时间表slideout: 一个非常美观的侧滑菜单 包管理工具 Package ManagersNPM菜鸟教程NPM 使用介绍 http://www.runoob.com/nodejs/nodejs-npm.html淘宝 NPM 镜像 https://npm.taobao.org/npm 模块安装机制简介 http://www.ruanyifeng.com/blog/2016/01/npm-install.htmlnpm包搜索地址 https://www.npmjs.com/ BowerBower中文网 http://www.bowercn.com/Bower：客户端库管理工具-阮一峰 http://javascript.ruanyifeng.com/tool/bower.html Yarnyarn中文网 https://yarnpkg.com/zh-Hans/快速、可靠、安全的依赖管理YARN 简介 https://www.ibm.com/developerworks/cn/data/library/bd-yarn-intro/ 编辑器 Text EditorsWebStorm官网下载 http://www.jetbrains.com/webstorm/download前端网破解版下载 http://www.qdfuns.com/tools VScode官网下载 https://code.visualstudio.com/vscode 插件精选 - 献给所有前端工程师https://segmentfault.com/a/1190000006697219 SublimeText官网下载 https://www.sublimetext.com/前端网破解版插件版下载 http://www.qdfuns.com/toolsSublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言Emmet：一个用于提高开发效率的编辑器插件，前身是Zen codingSublimeLinter: 一个提供代码质量检测的插件SublimeTmpl：快速新建指定的模版文件Syntax-highlighting-for-Sass：sass代码高亮插件MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等ApplySyntax: 辅助检测语法插件CTags: Sublime Text Ctags 支持插件, 需要安装 ctagssublime-react: React 代码高亮 Atom官网下载 https://atom.io/ HBuilder官网下载 http://www.dcloud.io/ JS框架 JS FrameworksBackboneBackbone.js API中文文档http://www.css88.com/doc/backbone/ AngularJs中文官方文档https://angular.cn/angularjs中文网http://www.apjs.net/angularjs教程http://www.angularjs.net.cn/Angular 基础入门http://www.cnblogs.com/micua/p/angular-essential.htmlangular-masonry: Masonry 的 AngularJS 插件，用于瀑布流angular-schema-form: 根据 JSON 生成响应的 Form 表单restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resourceng-cordova: Cordova 常用组件的 Angular 版本angular-translate: Angular 的国际化 (I18n)ng-inspector: Chrome 插件，用于调试 Angularangularjs-style-guide: AngularJS 代码风格ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Componentsmaterial: Google Material Design 效果的 Angular 实现angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级angular-filter: 一组有用的 Angular Filtersbindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能 React英文官方文档https://facebook.github.io/react/docs/hello-world.html中文官方文档http://reactjs.cn/react/docs/getting-started-zh-CN.htmlgitbooks手册https://hulufei.gitbooks.io/react-tutorial/content/introduction.html阮一峰react入门http://www.ruanyifeng.com/blog/2015/03/react.html阮一峰React Router入门http://www.ruanyifeng.com/blog/2016/05/react_router.htmlReact Router 中文文档https://react-guide.github.io/react-router-cn/react-redux 中文文档http://cn.redux.js.org/docs/react-redux/index.html阮一峰Redux 入门教程http://www.ruanyifeng.com/blogreact: React 框架源代码react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架react-hot-loader: 实时调整 React 组件效果grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JStouchstonejs: 基于 React 的手机应用前端框架essential-react: 基于 React, ES6, React-Router的一个应用脚手架react-router: React 路由解决方案 Vuevue官方http://cn.vuejs.org/vuex官方http://vuex.vuejs.org/zh-cn/vue-router官方https://router.vuejs.org/zh-cn/ UI框架 UI FrameworksBootstrap最受欢迎的 HTML、CSS 和 JS 框架 http://v3.bootcss.com/ Ionic一款接近原生的Html5移动App开发框架 会html css js就可以开发apphttp://www.ionic.wang/ FoundationFoundation 中文网 迄今为止最好的响应式前端框架http://www.foundcss.com FrozenUI移动端服务的前端框架http://frozenui.github.io/ materializecss基于Material Design的主流前端响应式框架http://www.materializecss.cn/ mui最接近原生APP体验的高性能前端框架http://dev.dcloud.net.cn/mui/ AntDesign和react配合的UI框架https://ant.design eleme和vue配合的UI框架http://element.eleme.io/ JS预处理 JS PreprocessorsTypeScriptTypeScript 入门教程 菜鸟教程http://www.runoob.com/TypeScript中文网https://www.tslang.cn/TypeScript教程gitbookhttps://www.gitbook.com/ CoffeeScriptCoffeeScript 中文http://coffee-script.org/CoffeeScript 实用手册 极客学院http://wiki.jikexueyuan.com/project/coffeescript/ 过程自动化 Process AutomationGruntGrunt中文网http://www.gruntjs.net/ Gulpgulp.js 中文网http://www.gulpjs.com.cn/gulp详细入门教程http://www.ydcss.com/前端构建工具gulpjs的使用介绍及技巧http://www.cnblogs.com/2050/p/4198792.htmlGulp开发教程https://www.w3ctech.com/topic/134 模板引擎 TemplatingHandlebarshandlebarsjs官网http://handlebarsjs.com/Handlebars中文文档http://www.360doc.com/content/Handlebars.js 中文文档http://keenwon.com/992.htmlHandlebars的使用方法文档整理http://www.tuicool.com/articles/fqQFN3 Hamlhaml官方文档https://github.com/haml/hamlhaml入门http://blog.csdn.net/napoay/article/details/50491363 JadeJade 官方的英文文档http://www.w3cplus.com/html/how-to-use-jade.htmlJade的使用http://www.w3cplus.com/html/how-to-use-jade.html带你学习Jade模板引擎视频http://www.imooc.com/learn/259 构建工具 Build ToolsRequireJSRequireJS 英文网http://requirejs.org/RequireJS 中文网http://requirejs.cn/require.js的用法-阮一峰http://www.ruanyifeng.com/blog seajsseajs文档http://seajs.org/docs/SeaJS从入门到原理http://www.tuicool.com/articles/FfEJv2u Browserify官网http://browserify.org/githubhttps://github.com/substack/node-browserify/ WebpackWebpack 中文指南http://webpackdoc.com/webpack的实例http://www.vichily.comwebpack的入门http://www.vichily.com一小时包教会 —— webpack 入门指南http://www.w2bc.com/Article/50764 CSS预处理器 CSS PreprocessorsSasssass入门http://www.w3cplus.com/sassguide/sass参考手册http://sass.bootcss.com/docs/sass-reference/SASS用法指南-阮一峰http://www.ruanyifeng.com/blog/ Lessless中文网http://lesscss.cn/less快速入门http://less.bootcss.com/ stylusstylus中文文档-张鑫旭http://www.zhangxinxu.com/jq/stylus/","categories":[{"name":"前端","slug":"前端","permalink":"https://lzxhh2017.github.io/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://lzxhh2017.github.io/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"https://lzxhh2017.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://lzxhh2017.github.io/tags/CSS/"}]},{"title":"Nginx+Tomcat搭建集群环境","date":"2018-12-15T14:38:19.000Z","path":"2018/12/15/Nginx-Tomcat搭建集群环境/","text":"前言 Nginx结合tomcat进行集群搭建。Nginx不仅仅是一个反向代理服务器，它本身也可以托管网站，作为Web服务器，进行Http服务处理。 一、Nginx介绍 Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 应用场景： http服务器。Nginx可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 二、tomcat集群 提高服务的性能，例如计算处理能力、并发能力等，以及实现服务的高可用性。 提供项目架构的横向扩展能力，增加集群中的机器就能提高集群的性能。 三、实现步骤 1、安装Nginx，通过https://nginx.org/en/download.html 下载，这里用的版本是nginx-1.14.2，下载解压即可。 2、准备两个tomcat 3、分别修改两个tomcat的启动端口，下面以apache-tomcat-7.0.202为例，打开server.xml 需要修改三处端口号： 123456789&lt;Server port=\"8007\" shutdown=\"SHUTDOWN\"&gt;&lt;Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;&lt;Connector port=\"8011\" protocol=\"AJP/1.3\" redirectPort=\"8443\"/&gt; 4、启动两个tomcat（运行bin文件夹下面的startup.bat），然后在浏览器中访问，查看是否启动正常，这里是修改了/webapps/ROOT路径下的默认页面index.jsp文件，访问如下图所示： 5、访问正常后，进行配置Nginx来实现负载均衡，打开Nginx文件夹中的nginx.conf文件 核心配置如下 6、配置完成后，启动Nginx: 7、浏览器进行访问localhost查看运行状况。（upstream指定了集群服务的各个服务的地址，weight来增加某个服务器的权重，也就意味着请求会被多转发到这个服务器上。）","categories":[{"name":"后端","slug":"后端","permalink":"https://lzxhh2017.github.io/categories/后端/"},{"name":"Tomcat","slug":"后端/Tomcat","permalink":"https://lzxhh2017.github.io/categories/后端/Tomcat/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://lzxhh2017.github.io/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","permalink":"https://lzxhh2017.github.io/tags/Nginx/"}]},{"title":"Oracle 11g导出空表、少表的解决方法","date":"2018-12-04T03:32:48.000Z","path":"2018/12/04/Oracle-11g导出空表、少表的解决方法/","text":"前言 Oracle11g有个新特性，这个新特性 “deferred_segment_creation” 含义是段延迟创建，默认是true。如果这个参数设置为true，你新创建了一个Table，并且没有向其中插入数据，那么这个表不会立即分配extend，也就是不占数据空间，即表不分配segment以节省空间，所以这些表也没能导出来。在系统表user_tables中也可以看到segment_treated的字段里是“NO”或者“YES”说明了某张表是否分配了segment。说白了是为了可以节省少量的空间。 解决方法如下： 1、查询该用户下的所有空表 1select table_name from user_tables where NUM_ROWS=0; 2、构建针对空表分配空间的命令语句 1select &apos;alter table &apos;||table_name||&apos; allocate extent;&apos; from user_tables where num_rows=0 or num_rows is null; 查询结果如下所示： 上述代码会产生批量的修改表extent的SQL语句，只需要将其生成的所有sql代码全部执行，就可以给每一张已经存在的表来分配segment。 接着用exp语句导出即可。 1exp system/manager@TEST file=d:\\daochu.dmp","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lzxhh2017.github.io/categories/数据库/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"https://lzxhh2017.github.io/categories/数据库/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]},{"title":"Oracle和MySQL递归查询本下级","date":"2018-11-23T11:14:33.000Z","path":"2018/11/23/Oracle和MySQL递归查询本下级/","text":"前言 Oracle 操作(select…start with…connect by…prior);Mysql需要建立函数进行操作。 Oracle数据库结构表如下： 123456789create table regions( region_id number(8) primary key, p_region_id number(10), region_path varchar2(255), region_grade number(8), local_name varchar2(100), zipcode varchar2(20), cod varchar2(4)); 查找一个节点下面的所有节点，其中region_id是传入的参数： 1SELECT * FROM regions START WITH region_id = 1 connect BY prior region_id = p_region_id; 查询结果如下所示： MySql数据库创建表 1234567891011DROP TABLE IF EXISTS `es_regions`;CREATE TABLE `regions` ( `region_id` int(10) NOT NULL AUTO_INCREMENT, `p_region_id` int(10) DEFAULT NULL, `region_path` varchar(255) DEFAULT NULL, `region_grade` int(8) DEFAULT NULL, `local_name` varchar(100) NOT NULL, `zipcode` varchar(20) DEFAULT NULL, `cod` varchar(4) DEFAULT NULL, PRIMARY KEY (`region_id`)) ENGINE=InnoDB AUTO_INCREMENT=489 DEFAULT CHARSET=utf8; 利用find_in_set()函数和group_concat()函数实现递归查询： 123456789101112131415161718DROP FUNCTION IF EXISTS querychild;SET GLOBAL log_bin_trust_function_creators = 1;DELIMITER $$CREATE FUNCTION querychild(param INT)RETURNS VARCHAR(4000)BEGINDECLARE temp VARCHAR(4000);DECLARE sname VARCHAR(4000);SET temp = &apos;$&apos;;SET sname = CAST(param AS CHAR);WHILE sname IS NOT NULL DOSET temp = CONCAT(temp,&apos;,&apos;,sname);SELECT GROUP_CONCAT(region_id) INTO sname FROM regions WHERE FIND_IN_SET(p_region_id,sname)&gt;0;END WHILE;RETURN temp;END $$ 调用方式： 1SELECT * FROM regions WHERE FIND_IN_SET(region_id, querychild(1)); 查询结果如下所示：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lzxhh2017.github.io/categories/数据库/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"https://lzxhh2017.github.io/categories/数据库/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lzxhh2017.github.io/tags/MySQL/"}]},{"title":"Oracle数据库初始化脚本","date":"2018-11-21T12:56:30.000Z","path":"2018/11/21/Oracle数据库初始化脚本/","text":"前言 Oracle数据库初始化：创建表空间；创建用户并赋予权限；数据导入。 创建表空间123create tablespace mhpt datafile &apos;E:\\htzqjj\\ts_data.ora&apos; size 1000m;select file_id from dba_data_files where tablespace_name=&apos;MHPT&apos;;alter database datafile 9 autoextend on next 10M; --9是之前查出的file_id; 创建用户并赋予权限1234567891011121314grant create any index to NAME;grant create database link to NAME;grant create procedure to NAME;grant create sequence to NAME;grant create table to NAME;grant create view to NAME;grant debug connect session to NAME;grant delete any table to NAME;grant select any table to NAME;grant unlimited tablespace to NAME;grant update any table to NAME;grant dba to NAME;grant connect to NAME;grant resource to NAME; 数据导入1imp mhpt/mhpt2@127.0.0.1/orcl file=D:\\mhpt_20170726.dmp log=D:\\temp\\log.txt full=y ignore=y","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lzxhh2017.github.io/categories/数据库/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"https://lzxhh2017.github.io/categories/数据库/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://lzxhh2017.github.io/tags/Oracle/"}]}]